Directory Structure:
.gitignore
CODE_OF_CONDUCT.md
DOCUMENTATION.md
LICENSE.txt
README.md
auto_swipe.py
quickstart.py
requirements.txt
scraper.py
setup.cfg
setup.py
[tinderbotz/]
    __init__.py
    addproxy.py
    [helpers/]
        __init__.py
        constants_helper.py
        email_helper.py
        geomatch.py
        geomatch_helper.py
        loadingbar.py
        login_helper.py
        match.py
        match_helper.py
        preferences_helper.py
        profile_helper.py
        storage_helper.py
        xpaths.py
    session.py


CODE_OF_CONDUCT.md:
```
# Contributor Covenant Code of Conduct

## Our Pledge

In the interest of fostering an open and welcoming environment, we as
contributors and maintainers pledge to making participation in our project and
our community a harassment-free experience for everyone, regardless of age, body
size, disability, ethnicity, sex characteristics, gender identity and expression,
level of experience, education, socio-economic status, nationality, personal
appearance, race, religion, or sexual identity and orientation.

## Our Standards

Examples of behavior that contributes to creating a positive environment
include:

* Using welcoming and inclusive language
* Being respectful of differing viewpoints and experiences
* Gracefully accepting constructive criticism
* Focusing on what is best for the community
* Showing empathy towards other community members

Examples of unacceptable behavior by participants include:

* The use of sexualized language or imagery and unwelcome sexual attention or
 advances
* Trolling, insulting/derogatory comments, and personal or political attacks
* Public or private harassment
* Publishing others' private information, such as a physical or electronic
 address, without explicit permission
* Other conduct which could reasonably be considered inappropriate in a
 professional setting

## Our Responsibilities

Project maintainers are responsible for clarifying the standards of acceptable
behavior and are expected to take appropriate and fair corrective action in
response to any instances of unacceptable behavior.

Project maintainers have the right and responsibility to remove, edit, or
reject comments, commits, code, wiki edits, issues, and other contributions
that are not aligned to this Code of Conduct, or to ban temporarily or
permanently any contributor for other behaviors that they deem inappropriate,
threatening, offensive, or harmful.

## Scope

This Code of Conduct applies both within project spaces and in public spaces
when an individual is representing the project or its community. Examples of
representing a project or community include using an official project e-mail
address, posting via an official social media account, or acting as an appointed
representative at an online or offline event. Representation of a project may be
further defined and clarified by project maintainers.

## Enforcement

Instances of abusive, harassing, or otherwise unacceptable behavior may be
reported by contacting the project team at frederik.mees@gmail.com. All
complaints will be reviewed and investigated and will result in a response that
is deemed necessary and appropriate to the circumstances. The project team is
obligated to maintain confidentiality with regard to the reporter of an incident.
Further details of specific enforcement policies may be posted separately.

Project maintainers who do not follow or enforce the Code of Conduct in good
faith may face temporary or permanent repercussions as determined by other
members of the project's leadership.

## Attribution

This Code of Conduct is adapted from the [Contributor Covenant][homepage], version 1.4,
available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html

[homepage]: https://www.contributor-covenant.org

For answers to common questions about this code of conduct, see
https://www.contributor-covenant.org/faq

```

DOCUMENTATION.md:
```
# Tinderbotz Documentation
Tinderbot exists around interacting with two types of users.</br>
1. ***Matches***</br>
Matches are profiles you have liked and whom have liked you back.</br>
You are now able to send them messages, gifs, songs, your social media and much more.</br>

2. ***Geomatches***</br>
Geomatches are users that fulfill **your criteria**, *such as distance, age and gender*, and by whom you fullfill **their criteria**.</br>
Seeing these profiles and thus '*breaking the first barrier of matching*' is why we name these profiles *geomatches*.</br>

<!-- TABLE OF CONTENTS -->
## Table of Contents
* [Creating a Session](#creating-a-session)
  * [Logging in to Tinder](#logging-in-to-tinder)
* [Settings](#settings)
  * [Custom Location](#custom-location)
  * [Email Notifications](#email-notifications)
  * [Distance Range](#distance-range)
  * [Age Range](#age-range)
  * [Sexuality](#sexuality)
  * [Global](#global)
* [Actions](#actions)
  * [Liking Geomatches](#liking-geomatches)
  * [Disliking Geomatches](#disliking-geomatches)
  * [Superliking Geomatches](#superliking-geomatches)
  * [Get Matches](#getting-matches)
  * [Get Geomatches](#getting-geomatches)
  * [Storing (geo)Matches](#storing-geomatches)
  * [Sending Messages](#sending-messages)
  * [Sending GIFS](#sending-gifs)
  * [Sending Songs](#sending-songs)
  * [Sending Socials](#sending-socials)
  * [Unmatching](#unmatching)
* [Getting Started](#just-let-me-start-already-yes-pls-ty)

# Creating a Session
First thing you'll have to do is import Session from tinderbot.session and create an active session.</br>
In this session we can adjust settings or take actions, such as liking or scraping data.
```
from tinderbot.session import Session

session = Session()
```
**Optional parameters**</br>
`headless`: *boolean*</br>
`store_session`: *boolean*</br>
`proxy`: *string*</br>

**Example usage**</br>
***headless*** might not work properly, so recommended to leave it on False. </br>
***store_session*** will store your cookies in a directory, so next time you don't need to login again. </br>
***proxy*** can be added using IP:PORT or HOST:PORT </br>
```
session = Session(headless=False, store_session=True, proxy="23.23.23.23:3128") 
```

## Logging in to Tinder
Logging in can be done in one of the following ways.
1. Using your Google-account: *Your email must be verified*
2. Using your Facebook-account: *Your Tinder must be connected to your Facebook*
3. Using your phone number: *This will require you to manually enter your received code*

### Login by Google & Facebook (RECOMMENDED)
```
session.login_using_google(email, password)
session.login_using_facebook(email, password)
```
**Required parameters**</br>
`email`: *string*</br>
`password`: *string*</br>

**Example usage**</br>
```
session.login_using_google("myemail@gmail.com", "password123")
session.login_using_facebook("myemail@gmail.com", "password123")
```

### Login by SMS (DEPRECATED)
```
session.login_using_sms(country, phone_number)
```
**Required parameters**</br>
`country`: *string*</br>
`phone_number`: *string*</br>

**Example usage**</br>
Let's say your phone_number is +32401234567, then </br>
***country*** is needed to get the right prefix, in my case +32 and</br>
***phone_number*** is everything after the prefix (+32).</br>
```
session.login_using_sms("Belgium", "401234567")
```
**NOTE**: this is not my phone number :)</br>


# Settings
## Custom Location
Changing location used to be a paid for ***Tinder Plus*** feature. But no more!</br>
We are now able to mask our position using geopositioning inside our browser.</br>
```
session.set_custom_location(latitude, longitude)
```
**Required parameters**</br>
`latitude`: *float*</br>
`longitude`: *float*</br>

**Optional parameters**</br>
`accuracy`: *string*</br>

***Note:*** By default, accuracy is 100%, which is recommended.</br>

**Example usage**</br>
In this example we set the location to the city Leuven in Belgium.</br>
You can find the latitude and longitude of a location online; for example [here](https://www.latlong.net).<br>
```
session.set_custom_location(latitude=50.879829, longitude=4.700540, accuracy="100%")
# would be the same as simply
session.set_custom_location(latitude=50.879829, longitude=4.700540)
```

## Email Notifications
You can activate the option to receive an email whenever you get a match. The email, which you've used to login with, is being used as recepient.
By default no emails are being sent. If you wish to receive emails you need to set this setting to **True**.
```
session.set_email_notifications(boolean)
```

**Required parameters**</br>
`boolean`: *boolean*</br>

**Example usage**</br>
```
session.set_email_notifications(True)
```

## Distance Range
The distance radius function allows you to set the maximum allowed distance to your potential matches.</br>
This setting requires you to be logged in on Tinder.</br>
Note: the parameter passed is the distance to you in ***kilometers***.
```
session.set_distance_radius(km)
```
**Required parameters**</br>
`km`: *integer*</br>

**Example usage**</br>
```
session.set_distance_radius(150)
```

## Age Range
First parameter is the minimum age, second parameter is the maximum age of the potential matches.</br>
This setting requires you to be logged in on Tinder.</br>
```
session.set_age_range(min, max)
```
**Required parameters**</br>
`min`: *integer*</br>
`max`: *integer*</br>

**Example usage**</br>
```
session.set_age_range(18, 25)
```

## Sexuality
[Click here](https://github.com/frederikme/TinderBotz/blob/master/tinderbotz/helpers/constants_helper.py) to see what sexualities are allowed by Tinder.</br>
This setting allows you to choose which gender you get to see and thus will be matched with.</br>
This setting requires you to be logged in on Tinder.</br>
```
from tinderbot.helpers.constants_helper import Sexuality
session.set_sexuality(type)
```
**Required parameters**</br>
`type`: *(enum) sexuality*</br>

**Example usage**</br>
```
session.set_sexuality(Sexuality.EVERYONE)
```

## Global
This setting allows you to match other people around the world.</br>
This setting requires you to be logged in on Tinder.</br>
```
session.set_global(boolean)
```
**Required parameters**</br>
`boolean`: *boolean*</br>

**Optional parameters**</br>
***Note: Currently this option is not available yet in this project. Please open an issue for feature request if you'd want this feature to be made available.***
`language`: [Click here](https://github.com/frederikme/TinderBotz/blob/master/tinderbotz/helpers/constants_helper.py) to see what global languages are available.</br>

**Example usage**</br>
```
session.set_global(True)
```

# Actions
## Liking Geomatches
Liking method has 4 optional parameters.</br>
The amount, which is by default equal to 1, specifies how many times the like button should be pressed.</br>
The ratio, which is by default 100%, is the chance the bot should press like or else dislike.</br>
The sleep, which is by default 0 seconds, is the amount of seconds the bot should sleep between likes.</br>
The randomize_sleep, which is by default True, if set to True, adds randomization to the provided time between likes.</br>

These last 3 should make sure you don't get banned. :)
```
session.like()
```
**Optional parameters**</br>
`amount`: *integer*</br>
`ratio`: *string*</br>
`sleep`: *integer*</br>

**Example usage**</br>
```
session.like(amount=10, ratio="72.5%", sleep=1)
```

## Disliking Geomatches
```
session.dislike()
```
**Optional parameters**</br>
`amount`: *integer*</br>

**Example usage**</br>
```
session.dislike(amount=25)
```

## Superliking Geomatches
```
session.superlike()
```
**Optional parameters**</br>
`amount`: *integer*</br>

**Example usage**</br>
```
session.superlike(amount=2)
```

## Getting Matches
Your matches can be placed into two categories:
1. New matches with whom you haven't exchanged messages with yet.
2. Messaged matches with whom you have already interacted.
These matches will be a list of objects of the [class Match](https://github.com/frederikme/TinderBotz/blob/master/tinderbotz/helpers/match.py) which is a childclass of the [class Geomatch](https://github.com/frederikme/TinderBotz/blob/master/tinderbotz/helpers/geomatch.py).
```
new_matches = session.get_new_matches()    
old_matches = session.get_messaged_matches()

# getting all matches can be done by adding both together
matches = new_matches + old_matches
```
**Optional parameters**</br>
`amount`: *amount*</br>
`quickload`: *boolean*</br>

**Example usage**</br>
```
new_matches = session.get_new_matches(amount=100, quickload=True)    
old_matches = session.get_messaged_matches(amount=15, quickload=False)
```
By default, all new and messaged matches are being loaded, although quite often it's more interesting to load only a handful matches. The amount of matches you want to fetch can be adjusted by specifying the amount of matches.</br>

**Note**: **quickload** is **True** by default when no parameter is passed. This makes sure the loading happens two times faster while still getting most of the information, but only ***a few images*** of the match are loaded. </br>
However when **quickload** is **False**, ***ALL images*** of the match are loaded.</br>

**Note**: When quickload is **False**, loading your matches might take a while depending on how many matches you have.</br>
This is because the session will iterate through every match and all their images one by one.</br>

Another option, besides quickloading, to reduce loading time is to store these matches at the first run as illustrated here: [Storing (geo)Matches](#storing-geomatches)</br>
and then load them from there in future runs.</br>

## Getting Geomatches
Get data *name, age, bio, distance, home, study, passions, images...* of the displayed geomatch and store it inside an object of the [class Geomatch()](https://github.com/frederikme/TinderBotz/blob/master/tinderbotz/helpers/geomatch.py).
```
geomatch = session.get_geomatch()
```
**Optional parameters**</br>
`quickload`: *boolean*</br>

**Note**: **quickload** is **True** by default when no parameter is passed. This makes sure the loading happens two times faster while still getting most of the information, but only ***a few images*** of the geomatch are loaded. </br>
However when **quickload** is **False**, ***ALL images*** of the geomatch are loaded.</br>

## Storing (geo)Matches
Every profile, also known as a (geo)match, can be stored locally. </br>
Storing data can be useful for reducing runtime, for example when needing to fetch your matches.</br>
```
matches = session.getAllMatches()
for match in matches:
   session.store_local(match)
   
geomatch = session.get_geomatch()
session.store_local(geomatch)
```
## Sending Messages
Messages can be sent to matches.</br>
[Scrape your matches](#getting-matches) or fetch them from your locally stored json file.</br>
 ```
id = match.get_chat_id()
name = match.get_name()
 
pickup_line = "Hey {}, you got look exactly like my future wife. ;)".format(name)

# send them a unique pick up line with their personal name
session.send_message(chatid=id, message=pickup_line)
```
## Sending GIFS
GIFS can be sent to matches.</br>
[Scrape your matches](#getting-matches) or get them from your locally stored json file.</br>
</br>
Sending a GIF will open the correct chat with your match, browse for the gif and send the first one that's being displayed.
```
id = match.get_chat_id()
session.send_gif(chatid=id, gifname="pizza")
```
## Sending Songs
Songs can be sent to matches.</br>
[Scrape your matches](#getting-matches) or get them from your locally stored json file.</br>
</br>
Sending a song will open the correct chat with your match, browse for the song and send the first one that's being displayed.
```
id = match.get_chat_id()
session.send_song(chatid=id, songname="cutiepie")
```
## Sending Socials
Socials can be sent to matches.</br>
[Scrape your matches](#getting-matches) or get them from your locally stored json file.</br>
</br>
There are different types of socials. [Click here](https://github.com/frederikme/TinderBotz/blob/master/tinderbotz/helpers/constants_helper.py) to see what types of social media or available.</br> 
```
id = match.get_chat_id()
session.send_socials(chatid=id, media=Socials.INSTAGRAM, value="Teeti.fm")
```
## Unmatching
You can unmatch a match. **BUT** think twice before you do. Once you unmatch, there is no going back.
```
id = match.get_chat_id()
session.unmatch(chatid=id)
```

# ***JUST LET ME START ALREADY YES PLS TY***
If you feel like you just want to dive right into the code and get started right away, this is where you need to be. :) </br>

1. Open the [quickstart.py](https://github.com/frederikme/TinderBotz/blob/master/quickstart.py) from the tinderbot directory.
2. Fill in your credentials (email and password) to be able to login to Tinder.
3. Change the quickstart script to your needs.
4. Run the code.

If you want to scrape as much *geomatches* as possible,</br>
then [scraper.py](https://github.com/frederikme/TinderBotz/blob/master/scraper.py) will suit your needs better.

```

README.md:
```
# Tinderbotz
**Consider giving a ⭐ if you like the project!**
## Project
<!-- PROJECT LOGO -->
<br />
<p align="center">
  <a href="https://user-images.githubusercontent.com/60892381/94200140-384a7f80-feba-11ea-8fcf-ec4507eda017.jpg">
    <img src="https://user-images.githubusercontent.com/60892381/94200140-384a7f80-feba-11ea-8fcf-ec4507eda017.jpg">
  </a>

  <h3 align="center">TINDERBOT AND PROFILESCRAPER</h3>

  <p align="center">
    Tinder web automation and scraper.
    <br />
    <a href="https://github.com/frederikme/TinderBot/blob/master/DOCUMENTATION.md"><strong>Explore the docs »</strong></a>
    <br />
    <br />
    <a href="#demonstration">View Demo</a>
    ·
    <a href="https://github.com/frederikme/TinderBot/issues/new?assignees=&labels=&template=bug_report.md&title=">Report Bug</a>
    ·
    <a href="https://github.com/frederikme/TinderBot/issues/new?assignees=&labels=&template=feature_request.md&title=">Request Feature</a>
  </p>
</p>

<!-- TABLE OF CONTENTS -->
## Table of Contents

* [About the Project](#about-the-project)
  * [Built With](#built-with)
  * [Breaking Record](#breaking-record)
* [Getting Started](#getting-started)
  * [Prerequisites](#prerequisites)
  * [Installation](#installation)
* [Usage](#usage-of-tinderbot)
  * [Documentation](DOCUMENTATION.md)
  * [Demo](#demonstration)
* [Example Data Analysis](#example-data-analysis)
* [Avoiding the Ban](#how-to-avoid-the-ban)
* [Support the Repository](#support-the-repository)
* [Other Tinder Repositories](#other-tinder-repositories)
* [Disclaimer](#disclaimer)

<!-- ABOUT THE PROJECT -->
## About the Project
**IMPORTANT: Starring the project indicates shows your appreciation and will result in new features being added!**</br>
</br>
This project started with the motivation of learning web automation further and scraping with Python.</br>
I managed to succesfully create a bot that could: </br>

* Open a browser and login to Tinder.com
* Setting a custom location for **FREE** (which is normally a paid-for-***Tinder Plus***-feature)
* Setting profile settings and preferences, such as distance radius, minimum and maximum age, sexuality.
* Accept all notifications and dismiss pop-ups
* Swiping x number of profiles left or right
* Scraping data of the profiles displayed, including, yet not limited to, name, age, bio, images, ...
* Sending personalized messages to your matches
* Sending you social media cards, like Instagram, Snapchat, Phonenumber and Facebook
* Sending GIFS and songs
* Unmatching

If you feel like diving right in, the [quickstart.py](https://github.com/frederikme/TinderBot/blob/master/quickstart.py) will help you be right on track.</br>
If you're new to coding and just want the script to automatically like, the [auto_swipe.py](https://github.com/frederikme/TinderBot/blob/master/auto_swipe.py) would be what you're looking for!</br>
*Feel free to make a pull request and contribute to this project!*</br>
</br>
***Enjoy! :)***</br>

***Youtube Video***
[![Getting +1000 Matches on Tinder in 24 Hours by Building a Tinderbot!](https://img.youtube.com/vi/qCgKlCi6YRI/0.jpg)](https://www.youtube.com/watch?v=qCgKlCi6YRI)

### Built with

* [Python](https://www.python.org/)
* [Selenium](https://selenium.dev)
* [Undetected-Chromedriver](https://github.com/ultrafunkamsterdam/undetected-chromedriver)

### Breaking Record
**I broke the world record most matches using this script!**</br>
Reached 1000 matches in the first 24hours.</br>
Currently at 30000 matches!</br>

<p align="left">
  <a href="https://user-images.githubusercontent.com/60892381/104088880-2d014100-526a-11eb-8b6d-ad1da6567778.jpg">
    <img src="https://user-images.githubusercontent.com/60892381/104088880-2d014100-526a-11eb-8b6d-ad1da6567778.jpg" width="250">
  </a>
</p>

<!-- Getting Started -->
## Getting Started
### Prerequisites

- Environment running python 3.x
- Tinder account with Google or Facebook login enabled

### Installation
#### Github
1. Clone or download the project
2. Install the required packages
```
pip3 install -r requirements.txt
```

## Usage of Tinderbot
### Features
Features of Tinderbot as demonstrated belowed can be found here: **[Tinderbot features](https://github.com/frederikme/TinderBot/blob/master/DOCUMENTATION.md)**</br>

### Demonstration
#### Setting some Profile settings
<img src="https://user-images.githubusercontent.com/60892381/99513887-682e7480-298b-11eb-810f-caae7424a792.gif"></src>

#### Liking 10 profiles in row + dismissing potential pop ups
<img src="https://user-images.githubusercontent.com/60892381/94987708-92a5a900-0568-11eb-88fc-f6be69354d73.gif"></src>

#### Scraping your matches (new matches + messaged matches)
<img src="https://user-images.githubusercontent.com/60892381/94995711-702f8200-05a0-11eb-9273-bfbb48ce168c.gif"></src>

#### Sending personalized messages to your matches
<img src="https://user-images.githubusercontent.com/60892381/94997724-43ce3280-05ad-11eb-8a94-0a66f0afbf93.gif"></src>

## Example Data Analysis
When scraping geomatches or your own matches, you can start doing some pretty cool stuff with that data.
A few examples are: 

#### Worldclouds
You can create wordclouds to visualise data such as the most popular names, or most occuring words in a bio.
<img src="https://user-images.githubusercontent.com/60892381/110502983-02adf180-80fc-11eb-85c4-a0cee0dd63f1.jpg"></src>
<img src="https://user-images.githubusercontent.com/60892381/110502986-03df1e80-80fc-11eb-9d86-c3cb38a553e5.jpg"></src>

#### The 'Average' Person
You can also start calculating what an 'average' tinderprofile would look like.</br>
You can for example check the average number of words a bio consists of or the average number of images a user has.
<img src="https://user-images.githubusercontent.com/60892381/94479341-f03a9e00-01d4-11eb-9a10-70a8aa8208ea.png"></src>

## How to Avoid the Ban
This small section will explain how their bot detection works and how you can avoid getting banned.</br>

### 1) Go easy with newly created profiles
Newly created profiles are much more likely to get banned than long-existing ones.</br>
*So be extra cautious!*</br>

### 2) Avoid the usage of URLS!
This one is very lethal for your accounts. Avoid sending urls to people in messages and **DO NOT** place any url in your bio!</br>

### 3) Avoid running the code overnight
Try to use the code when you can see it running. In case you need to handle something (like a captcha or anything) you can immediatly respond to it.
I've heard some people had to prove they were not bots by doing some captcha and this could age very poorly when you run it overnight. Myself however, I haven't yet had 'the honour' to be redirected to such a captcha. So if you play it safe, there would be no need to panic.

### 4) Implement sleeps between swipes 
This might sounds ridiculous, but most people take a look at the profile before they swipe it. Therefore instantly swiping right on every profile puts you in a 'non humanlike behaviour'-zone, which should be tried to be avoided. Adding a sleep between swipes can be done as described [here](https://github.com/frederikme/TinderBotz/blob/master/DOCUMENTATION.md#liking-geomatches). It is recommended to sleep at least 1 second between every swipe. If you have a rather new profile, then make it 2 or 3 (float numbers like 1.5 are also allowed).

### 5) Implement randomness in your liking and disliking
Same applies as above; most people dislike some profiles and like others. Not liking EVERY profile could help you stay under the radar.
Example of how to do so can be found [here](https://github.com/frederikme/TinderBotz/blob/master/DOCUMENTATION.md#liking-geomatches).

### 6) Make your profile look as real as possible
Your profile cannot look in any way like those spambots. Therefore a few things can be done.

#### 6.1) Verify your profile with the blue badge to prove it's really you
#### 6.2) Link your Instagram/Spotify/Facebook and verify your email
#### 6.3) Write a good bio, preferably with a minimum of 100 characters
#### 6.4) Add at least 3-4 images, preferably more

## Support the Repository
Feel free to make a pull request and contribute to this project.</br>
If you feel like buying me a drink:
* [Paypal](https://paypal.me/frederikmees)
* [Patreon](https://www.patreon.com/frederikme)
* [Buy Me A Coffee](https://www.buymeacoffee.com/frederikme)

## Other Tinder Repositories
![Imgur](https://imgur.com/hSVjccD.jpg)
- [Analysis of Tinder Likes from "Likes Sent"](https://github.com/acarter881/tinder_likes_data) <br>
This repository uses Selenium, pandas, BeautifulSoup, Excel, and more to glean meaningful insights from Tinder profile cards.

## Disclaimer
Using automated software on Tinder is against community guidelines and might get your account banned.</br>

Also for the section **data mining**: scraping profiles is not only against Tinder's policies, but it's also against the law in many places.</br>
People on Tinder did not give their permission to be stored by any other entity than Tinder itself and people have the right to be forgotten. (see: [GDPR in Europe](https://ec.europa.eu/info/law/law-topic/data-protection/data-protection-eu_en))</br>

So here's a reminder that this software is for **educational purposes only** and it cannot be held accountable for any consequences you may face by having used this tool. Neither personal (banned account) nor judicial (lawsuits for privacy violations).


```

auto_swipe.py:
```
'''
Created by Frederikme (TeetiFM)

This script is meant to be user friendly for beginning users.
Definitly take a look at quickstart.py for more features!
'''

from tinderbotz.session import Session
from tinderbotz.helpers.constants_helper import *

if __name__ == "__main__":

    # creates instance of session
    session = Session()
    
    # replace this with your own email and password!
    email = "example@gmail.com"
    password = "password123"
    
    # login using either your facebook account or google account (delete the line of code you don't need)
    session.login_using_facebook(email, password)
    session.login_using_google(email, password)
    
    # spam likes
    # amount -> amount of people you want to like
    # ratio  -> chance of liking/disliking
    # sleep  -> amount of seconds to wait before swiping again
    session.like(amount=100, ratio="72.5%", sleep=1)

```

quickstart.py:
```
'''
Created by Frederikme (TeetiFM)
'''

from tinderbotz.session import Session
from tinderbotz.helpers.constants_helper import *

if __name__ == "__main__":
    # creates instance of session
    session = Session()
    # Or if you want to use a proxy
    # AUTHORISED BY IP -> "HOST:PORT"
    # AUTHORISED BY USERNAME, PASSWORD -> "username:password@HOST:PORT"
    session = Session(proxy="23.23.23.23:3128")

    # set location (Don't need to be logged in for this)
    session.set_custom_location(latitude=50.879829, longitude=4.700540)
    
    # replace this with your own email and password!
    email = "example@gmail.com"
    password = "password123"
    
    # login using your google account with a verified email!
    session.login_using_google(email, password)

    # Alternatively you can login using facebook with a connected profile!
    session.login_using_facebook(email, password)

    # Alternatively, you can also use your phone number to login
    '''
    - country is needed to get the right prefix, in my case +32
    - phone_number is everything after the prefix (+32)
    NOTE: this is not my phone number :)
    '''
    country = "Belgium"
    phone_number = "479011124"
    session.login_using_sms(country, phone_number)

    # spam likes, dislikes and superlikes
    # to avoid being banned:
    #   - it's best to apply a randomness in your liking by sometimes disliking.
    #   - some sleeping between two actions is recommended
    # by default the amount is 1, ratio 100% and sleep 1 second
    session.like(amount=10, ratio="72.5%", sleep=1)
    session.dislike(amount=1)
    session.superlike(amount=1)
    
    # adjust allowed distance for geomatches
    # Note: PARAMETER IS IN KILOMETERS!
    session.set_distance_range(km=150)

    # set range of prefered age
    session.set_age_range(18, 55)

    # set interested in gender(s) -> options are: WOMEN, MEN, EVERYONE
    session.set_sexuality(Sexuality.WOMEN)

    # Allow profiles from all over the world to appear
    session.set_global(True)

    # Getting matches takes a while, so recommended you load as much as possible from local storage
    # get new matches, with whom you haven't interacted yet
    # Let's load the first 10 new matches to interact with later on.
    # quickload on false will make sure ALL images are stored, but this might take a lot more time
    new_matches = session.get_new_matches(amount=10, quickload=False)
    # get already interacted with matches (matches with whom you've chatted already)
    messaged_matches = session.get_messaged_matches()
    
    # you can store the data and images of these matches now locally in data/matches
    # For now let's just store the messaged_matches
    for match in messaged_matches:
        session.store_local(match)

    # Pick up line with their personal name so it doesn't look spammy
    pickup_line = "Hey {}! You. Me. Pizza? Or do you not like pizza?"

    # loop through my new matches and send them the first message of the conversation
    for match in new_matches:
        # store name and chatid in variables so we can use it more simply later on
        name = match.get_name()
        id = match.get_chat_id()

        print(name, id)

        # Format the match her/his name in your pickup line for a more personal approach.
        message = pickup_line.format(name)

        # send pick up line with their name in it to all my matches
        session.send_message(chatid=id, message=message)

        # send a funny gif
        session.send_gif(chatid=id, gifname="")

        # send a funny song
        session.send_song(chatid=id, songname="")

        # send instagram or other socials like facebook, phonenumber and snapchat
        session.send_socials(chatid=id, media=Socials.INSTAGRAM, value="Fredjemees")

        # you can also unmatch
        #session.unmatch(chatid=id)

    # let's scrape some geomatches now
    for _ in range(5):
        # get profile data (name, age, bio, images, ...)
        geomatch = session.get_geomatch(quickload=False)
        # store this data locally as json with reference to their respective (locally stored) images
        session.store_local(geomatch)
        # dislike the profile, so it will show us the next geomatch (since we got infinite amount of dislikes anyway)
        session.dislike()

```

scraper.py:
```
'''
Created by Frederikme (TeetiFM)
'''
import random, time
from tinderbotz.session import Session

if __name__ == "__main__":

    # creates instance of session
    session = Session()

    # set a custom location
    session.set_custom_location(latitude=50.879829, longitude=4.700540)
    
    # replace this with your own email and password!
    email = "example@gmail.com"
    password = "password123"
    
    # login using your google account with a verified email! Alternatively, you can use Facebook login
    session.login_using_facebook(email, password)

    # start scraping as much geomatches as possible
    while True:
        # When scraping we want ALL images and not just the first few.
        # If you want to scrape a lot quicker, I recommend putting quickload on True
        # But note that you'd only get 1-3 image urls instead of them all.
        geomatch = session.get_geomatch(quickload=False)

        # check if crucial data is not empty (This will rarely be the case tho, but we want a 'clean' dataset
        if geomatch.get_name() is not None \
                and geomatch.get_image_urls() != []:

            # let's store the data of the geomatch locally (this includes all images!)
            session.store_local(geomatch)

            # display the saved data on your console
            print(geomatch.get_dictionary())

            # account is scraped, now dislike and go next (since dislikes are infinite)
            # NOTE: if no amount is passed, it will dislike once -> same as => dislike(amount=1)
            # NOTE: if you have TinderPlus, -Gold or -Platinum you could also use session.like()
            session.dislike()

        else:
            # refresh webpage, and go for another geomatch
            session.browser.refresh()

        # make a random sleep between dislikes between 0 and 4 seconds to mimic looks human-like, not spammy behaviour
        sleepy_time = random.random() * 4
        time.sleep(sleepy_time)


```

setup.py:
```
import setuptools
from distutils.core import setup

setup(
  name='tinderbotz',         # How you named your folder
  packages=['tinderbotz'],   # Chose the same as "name"
  version='1.6',      # Start with a small number and increase it with every change you make
  license='MIT',        # Chose a license from here: https://help.github.com/articles/licensing-a-repository
  description='Tinder automated bot and data scraper',   # Give a short description about your library
  author='Frederik Mees',                   # Type in your name
  author_email='frederik.mees@gmail.com',      # Type in your E-Mail
  url='https://github.com/frederikme/TinderBotz',   # Provide either the link to your github or to your website
  download_url='https://github.com/frederikme/TinderBotz/archive/1.6.tar.gz',    # I explain this later on
  keywords=['Tinder', 'Automation', 'bot'],   # Keywords that define your project best
  install_requires=['selenium', 'webdriver-manager'],

  classifiers=[
    'Development Status :: 3 - Alpha',      # Chose either "3 - Alpha", "4 - Beta" or "5 - Production/Stable" as the current state of your loadingz
    'Intended Audience :: Developers',      # Define that your audience are developers
    'Topic :: Software Development :: Build Tools',
    'License :: OSI Approved :: MIT License',   # Again, pick a license
    'Programming Language :: Python :: 3',      #Specify which pyhton versions that you want to support
  ],
)

```

tinderbotz/__init__.py:
```
from tinderbotz.session import Session

from tinderbotz.helpers.profile_helper import ProfileHelper
from tinderbotz.helpers.preferences_helper import PreferencesHelper
from tinderbotz.helpers.geomatch import Geomatch
from tinderbotz.helpers.match import Match
from tinderbotz.helpers.geomatch_helper import GeomatchHelper
from tinderbotz.helpers.match_helper import MatchHelper
from tinderbotz.helpers.login_helper import LoginHelper
from tinderbotz.helpers.storage_helper import StorageHelper
from tinderbotz.helpers.loadingbar import LoadingBar

from tinderbotz.helpers.constants_helper import *
from tinderbotz.helpers.xpaths import *

```

tinderbotz/addproxy.py:
```
import zipfile

manifest_json = """
{
    "version": "1.0.0",
    "manifest_version": 2,
    "name": "Chrome Proxy",
    "permissions": [
        "proxy",
        "tabs",
        "unlimitedStorage",
        "storage",
        "<all_urls>",
        "webRequest",
        "webRequestBlocking"
    ],
    "background": {
        "scripts": ["background.js"]
    },
    "minimum_chrome_version":"22.0.0"
}
"""

background_js = """
var config = {
        mode: "fixed_servers",
        rules: {
        singleProxy: {
            scheme: "http",
            host: "%s",
            port: parseInt(%s)
        },
        bypassList: ["localhost"]
        }
    };

chrome.proxy.settings.set({value: config, scope: "regular"}, function() {});

function callbackFn(details) {
    return {
        authCredentials: {
            username: "%s",
            password: "%s"
        }
    };
}

chrome.webRequest.onAuthRequired.addListener(
            callbackFn,
            {urls: ["<all_urls>"]},
            ['blocking']
);
"""

def get_proxy_extension(PROXY_HOST, PROXY_PORT, PROXY_USER, PROXY_PASS):
    print(PROXY_HOST, PROXY_PORT, PROXY_USER, PROXY_PASS)
    pluginfile = 'proxy_auth_plugin.zip'

    with zipfile.ZipFile(pluginfile, 'w') as zp:
        zp.writestr("manifest.json", manifest_json)
        zp.writestr("background.js", background_js % (PROXY_HOST, PROXY_PORT, PROXY_USER, PROXY_PASS))

    return pluginfile
```

tinderbotz/helpers/__init__.py:
```

```

tinderbotz/helpers/constants_helper.py:
```
import enum


# Using enum class create enumerations
class Socials(enum.Enum):
    SNAPCHAT = "snapchat"
    INSTAGRAM = "instagram"
    PHONENUMBER = "phone"
    FACEBOOK = "facebook"


class Sexuality(enum.Enum):
    MEN = "Men"
    WOMEN = "Women"
    EVERYONE = "Everyone"


class Language(enum.Enum):
    ENGLISH = "English"
    AFRIKAANS = "Afrikaans"
    ARABIC = "Arabic"
    BULGARIAN = "Bulgarian"
    BOSNIAN = "Bosnian"
    CROATIAN = "Croatian"
    CZECH = "Czech"
    DANISH = "Danish"
    DUTCH = "Dutch"
    ESTONIAN = "Estonian"
    FINNISH = "Finnish"
    FRENCH = "French"
    GEORGIAN = "Georgian"
    GERMAN = "German"
    GREEK = "Greek"
    HINDI = "Hindi"
    HUNGARIAN = "Hungarian"
    INDONESIAN = "Indonesian"
    ITALIAN = "Italian"
    JAPANESE = "Japanese"
    KOREAN = "Korean"
    LATVIAN = "Latvian"
    LITHUANIAN = "Lithuanian"
    MACEDONIAN = "Macedonian"
    MALAY = "Malay"
    POLISH = "Polish"
    PORTUGUESE = "Portuguese"
    ROMANIAN = "Romanian"
    RUSSIAN = "Russian"
    SERBIAN = "Serbian"
    SPANISH = "Spanish"
    SLOVAK = "Slovak"
    SLOVENIAN = "Slovenian"
    SWEDISH = "Swedish"
    TAMIL = "Tamil"
    THAI = "Thai"
    TURKISH = "Turkish"
    UKRAINIAN = "Ukrainian"
    VIETNAMESE = "Vietnamese"
   
class Printouts(enum.Enum):
    BANNER = ''' 
         _____ _           _           _           _       
        |_   _(_)_ __   __| | ___ _ __| |__   ___ | |_ ____
          | | | | '_ \ / _` |/ _ \ '__| '_ \ / _ \| __|_  /
          | | | | | | | (_| |  __/ |  | |_) | (_) | |_ / / 
          |_| |_|_| |_|\__,_|\___|_|  |_.__/ \___/ \__/___|
        ----------------------------------------------------'''
    
    EXPLANATION = '''
Hi guys,

This code is opensource and available on GitHub.
repository: https://github.com/frederikme/TinderBotz

If you find the code useful, it would mean a lot if you can star the repository to show your appreciation.
If you're interested in learning how to write these bots yourself,
I will be making tutorials about python selenium automation soon.

youtube_channel: https://www.youtube.com/channel/UC1i3N9R9XYxt5Imi-auLPuA
tutorials that will be coming:
1. Scraping news on websites -> For absolute beginners, as an intro to selenium 
2. A simplified Tinderbot -> For beginners
3. Writing an automated chess bot to play on Chess.com using stockfish (currently a private repository). -> Advanced

Have a nice day,
Frederikme
'''

```

tinderbotz/helpers/email_helper.py:
```
import smtplib
from email.message import EmailMessage

class EmailHelper:

    # I created a gmail account for everyone to use, please don't abuse this.
    @staticmethod
    def send_mail_match_found(to):
        match_msg = "Congratulations you've been matched with someone. Please check your profile for more details."

        msg = EmailMessage()
        msg.set_content(match_msg)

        msg['Subject'] = 'NEW TINDER MATCH'
        msg['From'] = "github.tinderbotz@gmail.com"
        msg['To'] = to

        # Send the message via our own SMTP server.
        server = smtplib.SMTP_SSL('smtp.gmail.com', 465)
        server.login("github.tinderbotz@gmail.com", "kuzdys-1zafri-Pebzob")
        server.send_message(msg)
        server.quit()

```

tinderbotz/helpers/geomatch.py:
```
from tinderbotz.helpers.storage_helper import StorageHelper

class Geomatch:

    def __init__(self, name, age, work, study, home, gender, bio, lifestyle, basics, anthem, looking_for = None, distance = None, passions = None, image_urls = None, instagram = None):
        self.name = name
        self.age = age
        self.work = work
        self.study = study
        self.home = home
        self.gender = gender
        self.passions = passions
        self.bio = bio
        self.lifestyle = lifestyle
        self.basics = basics
        self.anthem = anthem
        self.looking_for = looking_for
        self.distance = distance
        self.image_urls = image_urls
        self.instagram = instagram

        # create a unique id for this person
        self.id = "{}{}_{}".format(name, age, StorageHelper.id_generator(size=4))
        self.images_by_hashes = []

    def get_images_ai_data(self):
        images_ai_data = []
        for image in self.image_urls:
            for image_ai_data in self._get_image_ai_data(image):
                images_ai_data.append(image_ai_data)
        return images_ai_data

    def _get_image_ai_data(self, image_url):
        from PIL import Image
        from deepface import DeepFace
        from io import BytesIO
        import requests
        import cv2
        import numpy as np
        resp = requests.get(image_url, stream=True).raw
        image = np.asarray(bytearray(resp.read()), dtype="uint8")
        image = cv2.imdecode(image, cv2.IMREAD_COLOR)
        return DeepFace.analyze(image, enforce_detection=False)

    def get_name(self):
        return self.name

    def get_age(self):
        return self.age

    def get_work(self):
        return self.work

    def get_study(self):
        return self.study

    def get_home(self):
        return self.home

    def get_gender(self):
        return self.gender

    def get_passions(self):
        return self.passions

    def get_bio(self):
        return self.bio

    def get_lifestyle(self):
        return self.lifestyle

    def get_basics(self):
        return self.basics

    def get_anthem(self):
        return self.anthem
    
    def get_looking_for(self):
        return self.looking_for

    def get_distance(self):
        return self.distance

    def get_image_urls(self):
        return self.image_urls

    def get_instagram(self):
        return self.instagram

    def get_id(self):
        return self.id

    def get_dictionary(self):
        data = {
            "name": self.get_name(),
            "age": self.get_age(),
            "work": self.get_work(),
            "study": self.get_study(),
            "home": self.get_home(),
            "gender": self.gender,
            "bio": self.get_bio(),
            "distance": self.get_distance(),
            "basics": self.get_basics(),
            "lifestyle": self.get_lifestyle(),
            "passions": self.get_passions(),
            "anthem": self.get_anthem(),
            "looking_for": self.get_looking_for(),
            "image_urls": self.image_urls,
            "images_by_hashes": self.images_by_hashes,
            "instagram": self.get_instagram(),
        }
        return data

```

tinderbotz/helpers/geomatch_helper.py:
```
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.common.exceptions import *
from selenium.webdriver.common.action_chains import ActionChains
from selenium.webdriver.common.keys import Keys
import time
import re
from tinderbotz.helpers.xpaths import content
from datetime import datetime

class GeomatchHelper:

    delay = 5

    HOME_URL = "https://www.tinder.com/app/recs"

    def __init__(self, browser):
        self.browser = browser
        if "/app/recs" not in self.browser.current_url:
            self._get_home_page()

    def like(self)->bool:
        try:
            # need to find better way
            #if 'profile' in self.browser.current_url:
            #    xpath = f'{content}/div/div[1]/div/main/div[1]/div/div/div[1]/div[2]/div/div/div[4]/button'

                # wait for element to appear
            #    WebDriverWait(self.browser, self.delay).until(EC.presence_of_element_located(
            #        (By.XPATH, xpath)))

                # locate like button
            #    like_button = self.browser.find_element(By.XPATH, xpath)

            #    like_button.click()

            #else:
            #    xpath = f'{content}/div/div[1]/div/main/div[1]/div/div/div[1]'

            #    WebDriverWait(self.browser, self.delay).until(EC.presence_of_element_located(
            #        (By.XPATH, xpath)))

             #   card = self.browser.find_element(By.XPATH, xpath)

            #    action = ActionChains(self.browser)
           #    action.drag_and_drop_by_offset(card, 200, 0).perform()

            action = ActionChains(self.browser)
            action.send_keys(Keys.ARROW_RIGHT).perform()
            #time.sleep(1)
            return True

        except (TimeoutException, ElementClickInterceptedException):
            self._get_home_page()

        return False

    def dislike(self):
        try:
            #if 'profile' in self.browser.current_url:
            #    xpath = f'{content}/div/div[1]/div/main/div[1]/div/div/div[1]/div[2]/div/div/div[2]/button'
                # wait for element to appear
            #    WebDriverWait(self.browser, self.delay).until(EC.presence_of_element_located(
            #        (By.XPATH, xpath)))

            #    dislike_button = self.browser.find_element(By.XPATH, xpath)

            #    dislike_button.click()
            #else:

            #    xpath = f'{content}/div/div[1]/div/main/div[1]/div/div/div[1]'

            #    WebDriverWait(self.browser, self.delay).until(EC.presence_of_element_located(
            #        (By.XPATH, xpath)))

            #    card = self.browser.find_element(By.XPATH, xpath)

            #    action = ActionChains(self.browser)
            #    action.drag_and_drop_by_offset(card, -200, 0).perform()
            
            action = ActionChains(self.browser)
            action.send_keys(Keys.ARROW_LEFT).perform()

            #time.sleep(1)
        except (TimeoutException, ElementClickInterceptedException):
            self._get_home_page()

    def superlike(self):
        try:
            if 'profile' in self.browser.current_url:
                xpath = f'{content}/div/div[1]/div/main/div[1]/div/div/div[1]/div[2]/div/div/div[3]/div/div/div/button'

                # wait for element to appear
                WebDriverWait(self.browser, self.delay).until(EC.presence_of_element_located(
                    (By.XPATH, xpath)))

                superlike_button = self.browser.find_element(By.XPATH, xpath)

                superlike_button.click()

            else:
                xpath = f'{content}/div/div[1]/div/main/div[1]/div/div/div[1]'

                WebDriverWait(self.browser, self.delay).until(EC.presence_of_element_located(
                    (By.XPATH, xpath)))

                card = self.browser.find_element(By.XPATH, xpath)

                action = ActionChains(self.browser)
                action.drag_and_drop_by_offset(card, 0, -200).perform()

            time.sleep(1)

        except (TimeoutException, ElementClickInterceptedException):
            self._get_home_page()

    def _open_profile(self, second_try=False):
        if self._is_profile_opened(): return;
        try:
            #xpath = '//button'
            #WebDriverWait(self.browser, self.delay).until(EC.presence_of_element_located(
            #    (By.XPATH, xpath)))
            #buttons = self.browser.find_elements(By.XPATH, xpath)

            #for button in buttons:
            #    # some buttons might not have a span as subelement
            #    try:
            #        text_span = button.find_element(By.XPATH, './/span').text
            #        if 'open profile' in text_span.lower():
            #            button.click()
            #            break
            #    except:
            #        continue

            # New Implementation
            action = ActionChains(self.browser)
            action.send_keys(Keys.ARROW_UP).perform()

            #time.sleep(1)

        except (ElementClickInterceptedException, TimeoutException):
            if not second_try:
                print("Trying again to locate the profile info button in a few seconds")
                time.sleep(2)
                self._open_profile(second_try=True)
            else:
                self.browser.refresh()
        except:
            self.browser.get(self.HOME_URL)
            if not second_try:
                self._open_profile(second_try=True)

    def get_name(self):
        if not self._is_profile_opened():
            self._open_profile()

        try:
            xpath = f'{content}/div/div[1]/div/main/div[1]/div/div/div[1]/div[1]/div/div[2]/div[1]/div/div[1]/div/h1'
            # wait for element to appear
            WebDriverWait(self.browser, self.delay).until(EC.presence_of_element_located(
                (By.XPATH, xpath)))

            element = self.browser.find_element(By.XPATH, xpath)

            name = element.text
            if not name:
                xpath2 = f'{content}/div/div[1]/div/main/div[1]/div/div/div[1]/div[1]/div/div[2]/div[1]/div/div[1]/div/h1'
                element2 = self.browser.find_element(By.XPATH, xpath2)
                name = element2.text

            return name
        except Exception as e:
            pass

    def get_age(self):
        if not self._is_profile_opened():
            self._open_profile()

        age = None

        try:
            xpath = f'{content}/div/div[1]/div/main/div[1]/div/div/div[1]/div[1]/div/div[2]/div[1]/div/div[1]/span'

            # wait for element to appear
            WebDriverWait(self.browser, self.delay).until(EC.presence_of_element_located(
                (By.XPATH, xpath)))

            element = self.browser.find_element(By.XPATH, xpath)
            try:
                age = int(element.text)
            except ValueError:
                age = None

        except:
            pass

        return age

    def is_verified(self):
        if not self._is_profile_opened():
            self._open_profile()

        xpath_badge = f'{content}/div/div[1]/div/main/div[1]/div/div/div[1]/div[1]/div/div[2]/div[1]/div/div[1]/div[2]'
        try:
            self.browser.find_element(By.XPATH, xpath_badge)
            return True

        except:
            return False

    _WORK_SVG_PATH = "M7.15 3.434h5.7V1.452a.728.728 0 0 0-.724-.732H7.874a.737.737 0 0 0-.725.732v1.982z"
    _STUDYING_SVG_PATH = "M11.87 5.026L2.186 9.242c-.25.116-.25.589 0 .705l.474.204v2.622a.78.78 0 0 0-.344.657c0 .42.313.767.69.767.378 0 .692-.348.692-.767a.78.78 0 0 0-.345-.657v-2.322l2.097.921a.42.42 0 0 0-.022.144v3.83c0 .45.27.801.626 1.101.358.302.842.572 1.428.804 1.172.46 2.755.776 4.516.776 1.763 0 3.346-.317 4.518-.777.586-.23 1.07-.501 1.428-.803.355-.3.626-.65.626-1.1v-3.83a.456.456 0 0 0-.022-.145l3.264-1.425c.25-.116.25-.59 0-.705L12.13 5.025c-.082-.046-.22-.017-.26 0v.001zm.13.767l8.743 3.804L12 13.392 3.257 9.599l8.742-3.806zm-5.88 5.865l5.75 2.502a.319.319 0 0 0 .26 0l5.75-2.502v3.687c0 .077-.087.262-.358.491-.372.29-.788.52-1.232.68-1.078.426-2.604.743-4.29.743s-3.212-.317-4.29-.742c-.444-.161-.86-.39-1.232-.68-.273-.23-.358-.415-.358-.492v-3.687z"
    _HOME_SVG_PATH = "M19.695 9.518H4.427V21.15h15.268V9.52zM3.109 9.482h17.933L12.06 3.709 3.11 9.482z"
    _LOCATION_SVG_PATH = "M11.436 21.17l-.185-.165a35.36 35.36 0 0 1-3.615-3.801C5.222 14.244 4 11.658 4 9.524 4 5.305 7.267 2 11.436 2c4.168 0 7.437 3.305 7.437 7.524 0 4.903-6.953 11.214-7.237 11.48l-.2.167zm0-18.683c-3.869 0-6.9 3.091-6.9 7.037 0 4.401 5.771 9.927 6.897 10.972 1.12-1.054 6.902-6.694 6.902-10.95.001-3.968-3.03-7.059-6.9-7.059h.001z"
    _LOCATION_SVG_PATH_2 = "M11.445 12.5a2.945 2.945 0 0 1-2.721-1.855 3.04 3.04 0 0 1 .641-3.269 2.905 2.905 0 0 1 3.213-.645 3.003 3.003 0 0 1 1.813 2.776c-.006 1.653-1.322 2.991-2.946 2.993zm0-5.544c-1.378 0-2.496 1.139-2.498 2.542 0 1.404 1.115 2.544 2.495 2.546a2.52 2.52 0 0 0 2.502-2.535 2.527 2.527 0 0 0-2.499-2.545v-.008z"
    _GENDER_SVG_PATH = "M15.507 13.032c1.14-.952 1.862-2.656 1.862-5.592C17.37 4.436 14.9 2 11.855 2 8.81 2 6.34 4.436 6.34 7.44c0 3.07.786 4.8 2.02 5.726-2.586 1.768-5.054 4.62-4.18 6.204 1.88 3.406 14.28 3.606 15.726 0 .686-1.71-1.828-4.608-4.4-6.338"

    def get_row_data(self):
        if not self._is_profile_opened():
            self._open_profile()

        rowdata = {}

        xpath = '//div[@class="Row"]'
        rows = self.browser.find_elements(By.XPATH, xpath)

        for row in rows:
            svg = row.find_element(By.XPATH, ".//*[starts-with(@d, 'M')]").get_attribute('d')
            value = row.find_element(By.XPATH, ".//div[2]").text
            if svg == self._WORK_SVG_PATH:
                rowdata['work'] = value
            if svg == self._STUDYING_SVG_PATH:
                rowdata['study'] = value
            if svg == self._HOME_SVG_PATH:
                rowdata['home'] = value.split(' ')[-1]
            if svg == self._GENDER_SVG_PATH:
                rowdata['gender'] = value
            if svg == self._LOCATION_SVG_PATH or svg == self._LOCATION_SVG_PATH_2:
                distance = value.split(' ')[0]
                try:
                    distance = int(distance)
                except TypeError:
                    # Means the text has a value of 'Less than 1 km away'
                    distance = 1
                except ValueError:
                    distance = None

                rowdata['distance'] = distance

        return rowdata

    def get_bio_and_passions(self):
        if not self._is_profile_opened():
            self._open_profile()

        bio = None
        looking_for = None

        infoItems = {
            "passions": [],
            "lifestyle": [],
            "basics": []
        }

        anthem = None

        lifestyle = []


        # Bio
        try:
            bio = self.browser.find_element(By.CSS_SELECTOR, 'div[class*="Px(16px) Py(12px) Us(t)"').text

        except Exception as e:
            pass

        # Looking for
        try:
            looking_for_el = self.browser.find_element(By.CSS_SELECTOR, 'div[class="Px(16px) My(12px)"]>div[class="D(b)"]')
            looking_for = looking_for_el.find_element(By.CSS_SELECTOR, 'div[class="Typs(subheading-1) CenterAlign"]').text

        except Exception as e:
            pass

        # Basics, Lifestyle and Passions
        try:
            sections = self.browser.find_elements(By.CSS_SELECTOR, "div[class='Px(16px) Py(12px)']")
            for section in sections:
                headline = section.find_element(By.TAG_NAME, "h2").text.lower()
                
                if headline in infoItems.keys():
                    infoElements = section.find_elements(By.CSS_SELECTOR, "div[class^='Bdrs(100px)']")
                    for infoElement in infoElements:
                        infoItems[headline].append(infoElement.text)
                elif headline == 'my anthem':
                    song = section.find_element(By.CSS_SELECTOR, "div[class$='C($c-ds-text-primary)']").text
                    artist = section.find_element(By.CSS_SELECTOR, "div[class$='C($c-ds-text-secondary)']").text
                    anthem = {
                        "song": song,
                        "artist": artist
                    }
                else:
                    print("Unknown Sect Headline:", headline)


            #if ('Passions' in passions_el.find_element(By.TAG_NAME, "h2").text):
            #    #print("Passions Text", passions_el.text)
            #    elements = passions_el.find_element(By.TAG_NAME, 'div').find_element(By.TAG_NAME, 'div').find_elements(By.TAG_NAME, 'div')
            #    for el in elements:
            #        passions.append(el.text)
        except Exception as e:
            pass

        return bio, infoItems["passions"], infoItems["lifestyle"], infoItems["basics"], anthem, looking_for

    def get_image_urls(self, quickload=True):
        if not self._is_profile_opened():
            self._open_profile()

        image_urls = []

        # only get url of first few images, and not click all bullets to get all image
        elements = self.browser.find_elements(By.XPATH, "//div[@aria-label='Profile slider']")
        for element in elements:
            image_url = element.value_of_css_property('background-image').split('\"')[1]
            if image_url not in image_urls:
                image_urls.append(image_url)

        # return image urls without opening all images
        if quickload:
            return image_urls

        try:
            # There are no bullets when there is only 1 image
            classname = 'bullet'

            # wait for element to appear
            WebDriverWait(self.browser, self.delay).until(EC.presence_of_element_located(
                (By.CLASS_NAME, classname)))

            image_btns = self.browser.find_elements_by_class_name(classname)

            for btn in image_btns:
                btn.click()
                time.sleep(1)

                elements = self.browser.find_elements(By.XPATH, "//div[@aria-label='Profile slider']")
                for element in elements:
                    image_url = element.value_of_css_property('background-image').split('\"')[1]
                    if image_url not in image_urls:
                        image_urls.append(image_url)

        except StaleElementReferenceException:
            pass

        except TimeoutException:
            # there is only 1 image, so no bullets to iterate through
            try:
                element = self.browser.find_element(By.XPATH, "//div[@aria-label='Profile slider']")
                image_url = element.value_of_css_property('background-image').split('\"')[1]
                if image_url not in image_urls:
                    image_urls.append(image_url)

            except Exception as e:
                print("unhandled Exception when trying to store their only image")
                print(e)

        except Exception as e:
            print("unhandled exception getImageUrls in geomatch_helper")
            print(e)

        return image_urls

    @staticmethod
    def de_emojify(text):
        """Remove emojis from a string
        Args:
            text (string): string with emojis or not
        Returns:
            string: recompile string without emojis
        """
        regrex_pattern = re.compile(
            pattern="["
                    u"\U0001F600-\U0001F64F"  # emoticons
                    u"\U0001F300-\U0001F5FF"  # symbols & pictographs
                    u"\U0001F680-\U0001F6FF"  # transport & map symbols
                    u"\U0001F1E0-\U0001F1FF"  # flags (iOS)
                    "]+",
            flags=re.UNICODE,
        )
        return regrex_pattern.sub(r'', text)

    def get_insta(self, text):
        """Take the bio and read line by line to match if the description
        contain an instagram user.
        Args:
            text (string): string with emojis or not
        Returns:
            ig (string): return valid instagram user.
        """
        if not text:
            return None
        valid_pattern = [
            "@",
            "ig-",
            "ig",
            "ig:",
            "ing",
            "ing:",
            "instag",
            "instag:",
            "insta:",
            "insta",
            "inst",
            "inst:",
            "instagram",
            "instagram:",
        ]
        description = text.rstrip().lower().strip()
        description = description.split()
        for x in range(len(description)):
            ig = self.de_emojify(description[x])
            if '@' in ig:
                return ig.replace('@', '')
            elif ig in valid_pattern:
                try:
                    if ':' in description[x + 1]:
                        return description[x + 2]
                    else:
                        return description[x + 1]
                except:
                    return None
            else:
                try:
                    ig = ig.split(':', 1)
                    if ig[0] in valid_pattern:
                        return ig[-1]
                except:
                    return None
        return None

    def _get_home_page(self):
        self.browser.get(self.HOME_URL)
        time.sleep(5)

    def _is_profile_opened(self):
        if '/profile' in self.browser.current_url:
            return True
        else:
            return False

```

tinderbotz/helpers/loadingbar.py:
```
import sys
import time

class LoadingBar:

    def __init__(self, length_of_loop, explanation="", amount_of_bars=30):

        self.length_of_loop = length_of_loop
        self.explanation = explanation
        self.amount_of_bars = amount_of_bars
        self.update_loading(index=-1)

    def update_loading(self, index):
        sys.stdout.write('\r')

        # To avoid dividing by Zero, let's do a check
        if self.length_of_loop == 0:
            percentage_loaded = 100
        else:
            percentage_loaded = int((index + 1)*100 / self.length_of_loop)

        if percentage_loaded > 100:
            percentage_loaded = 100

        # [===>----] 45% of new matches scraped
        amount_of_equals = int(percentage_loaded / 100 * self.amount_of_bars)
        amount_of_minus = self.amount_of_bars - amount_of_equals - 1

        printout = "[{}>{}] {}% of the {} handled.".format('=' * amount_of_equals, '-' * amount_of_minus, percentage_loaded,
                                            self.explanation)
        sys.stdout.write(printout)
        sys.stdout.flush()
        time.sleep(0.25)

        if percentage_loaded == 100:
            print("\n")

```

tinderbotz/helpers/login_helper.py:
```
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.common.exceptions import TimeoutException, ElementClickInterceptedException, StaleElementReferenceException, NoSuchElementException
from selenium.webdriver.common.keys import Keys
from tinderbotz.helpers.xpaths import content
import time

class LoginHelper:

    delay = 7

    def __init__(self, browser):
        self.browser = browser
        self._accept_cookies()

    def _click_login_button(self):
        try:
            xpath = f'{content}/div/div[1]/div/main/div[1]/div/div/div/div/header/div/div[2]/div[2]/a'
            WebDriverWait(self.browser, self.delay).until(EC.presence_of_element_located(
                (By.XPATH, xpath)))
            button = self.browser.find_element(By.XPATH, xpath)
            button.click()
            time.sleep(3)

        except TimeoutException:
            self._exit_by_time_out()

        except ElementClickInterceptedException:
            pass

    def login_by_google(self, email, password):
        self._click_login_button()

        # wait for google button to appear
        xpath = '//*[@aria-label="Log in with Google"]'
        try:
            WebDriverWait(self.browser, self.delay).until(EC.presence_of_element_located(
                (By.XPATH, xpath)))

            self.browser.find_element(By.XPATH, xpath).click()

        except TimeoutException:
            self._exit_by_time_out()
        except StaleElementReferenceException:
            # page was still loading when attempting to click facebook login
            time.sleep(4)
            self.browser.find_element(By.XPATH, xpath).click()

        if not self._change_focus_to_pop_up():
            print("FAILED TO CHANGE FOCUS TO POPUP")
            print("Let's try again...")
            return self.login_by_google(email, password)

        try:
            xpath = "//input[@type='email']"
            WebDriverWait(self.browser, self.delay).until(
                EC.presence_of_element_located((By.XPATH, xpath)))

            emailfield = self.browser.find_element(By.XPATH, xpath)
            emailfield.send_keys(email)
            emailfield.send_keys(Keys.ENTER)
            # sleeping 3 seconds for passwordfield to come through
            time.sleep(3)
        except TimeoutException:
            self._exit_by_time_out()

        try:
            xpath = "//input[@type='password']"
            WebDriverWait(self.browser, self.delay).until(
                EC.presence_of_element_located((By.XPATH, xpath)))

            pwdfield = self.browser.find_element(By.XPATH, xpath)
            pwdfield.send_keys(password)
            pwdfield.send_keys(Keys.ENTER)

        except TimeoutException:
            self._exit_by_time_out()

        self._change_focus_to_main_window()
        self._handle_popups()

    def login_by_facebook(self, email, password):
        self._click_login_button()

        # wait for facebook button to appear
        xpath = '//*[@aria-label="Log in with Facebook"]'
        try:
            WebDriverWait(self.browser, self.delay).until(EC.presence_of_element_located(
                (By.XPATH, xpath)))

            self.browser.find_element(By.XPATH, xpath).click()
        except TimeoutException:
            self._exit_by_time_out()
        except StaleElementReferenceException:
            # page was still loading when attempting to click facebook login
            time.sleep(4)
            self.browser.find_element(By.XPATH, xpath).click()

        if not self._change_focus_to_pop_up():
            print("FAILED TO CHANGE FOCUS TO POPUP")
            print("Let's try again...")
            return self.login_by_facebook(email, password)

        try:
            xpath_cookies = '//*[@data-cookiebanner="accept_button"]'

            WebDriverWait(self.browser, self.delay).until(
            EC.presence_of_element_located((By.XPATH, xpath_cookies)))

            self.browser.find_element(By.XPATH, xpath_cookies).click()
        except TimeoutException:
            # Not everyone might have the cookie banner so let's just continue then
            pass

        try:
            xpath_email = '//*[@id="email"]'
            xpath_password = '//*[@id="pass"]'
            xpath_button = '//*[@id="loginbutton"]'

            WebDriverWait(self.browser, self.delay).until(
                EC.presence_of_element_located((By.XPATH, xpath_email)))

            emailfield = self.browser.find_element(By.XPATH, xpath_email)
            emailfield.send_keys(email)

            pwdfield = self.browser.find_element(By.XPATH, xpath_password)
            pwdfield.send_keys(password)

            loginbutton = self.browser.find_element(By.XPATH, xpath_button)
            loginbutton.click()

        except TimeoutException:
            self._exit_by_time_out()

        self._change_focus_to_main_window()
        self._handle_popups()

    def login_by_sms(self, country, phone_number):
        self._click_login_button()

        # wait for facebook button to appear
        try:
            xpath = '//*[@aria-label="Log in with phone number"]'
            WebDriverWait(self.browser, self.delay).until(EC.presence_of_element_located(
                (By.XPATH, xpath)))

            btn = self.browser.find_element(By.XPATH, xpath)
            btn.click()
        except TimeoutException:
            self._exit_by_time_out()

        self._handle_prefix(country)

        # Fill in sms
        try:
            xpath = '//*[@name="phone_number"]'
            WebDriverWait(self.browser, self.delay).until(EC.presence_of_element_located(
                    (By.XPATH, xpath)))

            field = self.browser.find_element(By.XPATH, xpath)
            field.send_keys(phone_number)
            field.send_keys(Keys.ENTER)

        except TimeoutException:
            self._exit_by_time_out()

        print("\n\nPROCEED MANUALLY BY ENTERING SMS CODE\n")
        # check every second if user has bypassed sms-code barrier
        while not self._is_logged_in():
            time.sleep(1)

        self._handle_popups()

    def _handle_prefix(self, country):
        self._accept_cookies()

        xpath = '//div[@aria-describedby="phoneErrorMessage"]/div/div'
        WebDriverWait(self.browser, self.delay).until(EC.presence_of_element_located(
            (By.XPATH, xpath)))
        btn = self.browser.find_element(By.XPATH, xpath)
        btn.click()

        els = self.browser.find_elements(By.XPATH, '//div')
        for el in els:
            try:
                span = el.find_element(By.XPATH, './/span')
                if span.text.lower() == country.lower():
                    print("clicked")
                    el.click()
                    break
                else:
                    print(span.text)
            except:
                continue

    # checks if user is logged in by checking the url
    def _is_logged_in(self):
        return 'app' in self.browser.current_url

    def _handle_popups(self):
        for _ in range(20):
            if not self._is_logged_in():
                time.sleep(1.2)
            else:
                break

        if not self._is_logged_in():
            print('Still not logged in ... ?')
            input('Proceed manually and press ENTER to continue\n')

        time.sleep(2)
        self._accept_cookies()
        self._accept_location_notification()
        self._deny_overlayed_notifications()

        #self.browser.execute_cdp_cmd(
        #    "Browser.grantPermissions",
        #    {
        #        "origin": "https://www.tinder.com",
        #        "permissions": ["geolocation"]
        #    },
        #)

        time.sleep(5)

    def _accept_location_notification(self):
        try:
            xpath = '//*[@data-testid="allow"]'
            WebDriverWait(self.browser, self.delay).until(
                EC.presence_of_element_located((By.XPATH, xpath)))

            locationBtn = self.browser.find_element(By.XPATH, xpath)
            locationBtn.click()
            print("ACCEPTED LOCATION.")
        except TimeoutException:
            print(
                "ACCEPTING LOCATION: Loading took too much time! Element probably not presented, so we continue.")
        except:
            pass

    def _deny_overlayed_notifications(self):
        try:
            xpath = '//*[@data-testid="decline"]'
            WebDriverWait(self.browser, self.delay).until(
                EC.presence_of_element_located((By.XPATH, xpath)))

            self.browser.find_element(By.XPATH, xpath).click()
            print("DENIED NOTIFICATIONS.")
        except TimeoutException:
            print(
                "DENYING NOTIFICATIONS: Loading took too much time! Element probably not presented, so we continue.")
        except:
            pass

    def _accept_cookies(self):
        try:
            xpath = '//*[@type="button"]'
            WebDriverWait(self.browser, self.delay).until(EC.presence_of_element_located(
                (By.XPATH, xpath)))
            buttons = self.browser.find_elements(By.XPATH, xpath)

            for button in buttons:
                try:
                    text_span = button.find_element(By.XPATH, './/span').text
                    if 'accept' in text_span.lower():
                        button.click()
                        print("COOKIES ACCEPTED.")
                        break
                except NoSuchElementException:
                    pass

        except TimeoutException:
            print(
                "ACCEPTING COOKIES: Loading took too much time! Element probably not presented, so we continue.")
        except Exception as e:
            print("Error cookies", e)
            pass

    def _change_focus_to_pop_up(self):
        max_tries = 50
        current_tries = 0

        main_window = None
        while not main_window and current_tries < max_tries:
            current_tries += 1
            main_window = self.browser.current_window_handle

        current_tries = 0
        popup_window = None
        while not popup_window:
            current_tries += 1
            time.sleep(0.30)
            if current_tries >= max_tries:
                print("tries exceeded")
                return False

            for handle in self.browser.window_handles:
                if handle != main_window:
                    popup_window = handle
                    break

        self.browser.switch_to.window(popup_window)
        return True

    def _change_focus_to_main_window(self):
        main_window = None
        if len(self.browser.window_handles) == 1:
            main_window = self.browser.current_window_handle
        else:
            popup_window = self.browser.current_window_handle
            while not main_window:
                for handle in self.browser.window_handles:
                    if handle != popup_window:
                        main_window = handle
                        break

        self.browser.switch_to.window(main_window)

    def _exit_by_time_out(self):
        print("Loading an element took too much time!. Please check your internet connection.")
        print("Alternatively, you can add a sleep or higher the delay class variable.")
        exit(1)

```

tinderbotz/helpers/match.py:
```
from tinderbotz.helpers.geomatch import Geomatch

# A match has the same information as a geomatch, except that you have a chatroom with an id
class Match(Geomatch):

    def __init__(self, name, chatid, age, work, study, home, gender, bio, distance, passions, image_urls):
        self.chatid = chatid

        # invoking the __init__ of the parent class
        Geomatch.__init__(self, name, age, work, study, home, gender, bio, distance, passions, image_urls)

    def get_chat_id(self):
        return self.chatid

    def get_dictionary(self):
        data = {
            "name": self.get_name(),
            "age": self.get_age(),
            "work": self.get_work(),
            "study": self.get_study(),
            "home": self.get_home(),
            "gender": self.get_gender(),
            "bio": self.get_bio(),
            "distance": self.get_distance(),
            "passions": self.get_passions(),
            "image_urls": self.image_urls,
            "images_by_hashes": self.images_by_hashes,
            "chatid": self.get_chat_id()
        }
        return data

```

tinderbotz/helpers/match_helper.py:
```
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.common.exceptions import TimeoutException, StaleElementReferenceException, NoSuchElementException
import time

from tinderbotz.helpers.match import Match
from tinderbotz.helpers.constants_helper import Socials
from tinderbotz.helpers.loadingbar import LoadingBar
from tinderbotz.helpers.xpaths import content, modal_manager

class MatchHelper:

    delay = 5

    HOME_URL = "https://tinder.com/app/recs"

    def __init__(self, browser):
        self.browser = browser

    def _scroll_down(self, xpath):
        eula = self.browser.find_element(By.XPATH, xpath)
        self.browser.execute_script('arguments[0].scrollTop = arguments[0].scrollHeight', eula)

        SCROLL_PAUSE_TIME = 0.5

        # Get scroll height
        last_height = self.browser.execute_script("arguments[0].scrollHeight", eula)

        while True:
            # Scroll down to bottom
            self.browser.execute_script("arguments[0].scrollTo(0, arguments[0].scrollHeight);", eula)

            # Wait to load page
            time.sleep(SCROLL_PAUSE_TIME)

            # Calculate new scroll height and compare with last scroll height
            new_height = self.browser.execute_script("arguments[0].scrollHeight", eula)
            if new_height == last_height:
                return True
            last_height = new_height


    def get_chat_ids(self, new, messaged):
        chatids = []

        xpath = '//button[@role="tab"]'
        try:
            WebDriverWait(self.browser, self.delay).until(EC.presence_of_element_located((By.XPATH, xpath)))
        except TimeoutException:
            print("match tab could not be found, trying again")
            self.browser.get(self.HOME_URL)
            time.sleep(1)
            return self.get_chat_ids(new, messaged)

        tabs = self.browser.find_elements(By.XPATH, xpath)

        if new:
            # Make sure we're in the 'new matches' tab
            for tab in tabs:
                if tab.text == 'Matches':
                    try:
                        tab.click()
                    except:
                        self.browser.get(self.HOME_URL)
                        return self.get_chat_ids(new, messaged)


            # start scraping new matches
            try:
                xpath = '//div[@role="tabpanel"]'

                # wait for element to appear
                WebDriverWait(self.browser, self.delay).until(EC.presence_of_element_located((By.XPATH, xpath)))

                div = self.browser.find_element(By.XPATH, xpath)

                list_refs = div.find_elements(By.XPATH, './/div/div/a')
                for index in range(len(list_refs)):
                    try:
                        ref = list_refs[index].get_attribute('href')
                        if "likes-you" in ref or "my-likes" in ref:
                            continue
                        else:
                            chatids.append(ref.split('/')[-1])
                    except:
                        continue

            except NoSuchElementException:
                pass

        if messaged:
            # Make sure we're in the 'messaged matches' tab
            for tab in tabs:
                if tab.text == 'Messages':
                    try:
                        tab.click()
                    except:
                        self.browser.get(self.HOME_URL)
                        return self.get_chat_ids(new, messaged)

            # Start scraping the chatted matches
            try:
                xpath = '//div[@class="messageList"]'

                # wait for element to appear
                WebDriverWait(self.browser, self.delay).until(EC.presence_of_element_located(
                    (By.XPATH, xpath)))

                div = self.browser.find_element(By.XPATH, xpath)

                list_refs = div.find_elements(By.XPATH, './/a')
                for index in range(len(list_refs)):
                    try:
                        ref = list_refs[index].get_attribute('href')
                        chatids.append(ref.split('/')[-1])
                    except:
                        continue

            except NoSuchElementException:
                pass

        return chatids

    def get_new_matches(self, amount, quickload):
        matches = []
        used_chatids = []
        iteration = 0
        while True:
            iteration += 1
            if len(matches) >= amount:
                break

            new_chatids = self.get_chat_ids(new=True, messaged=False)
            copied = new_chatids.copy()
            for index in range(len(copied)):
                chatid = copied[index]
                if chatid in used_chatids:
                    new_chatids.remove(chatid)
                else:
                    used_chatids.append(chatid)

            # no new matches are found, MAX LIMIT
            if len(new_chatids) == 0:
                break

            # shorten the list so doesn't fetch ALL matches but just the amount it needs
            diff = len(matches) + len(new_chatids) - amount

            if diff > 0:
                del new_chatids[-diff:]

            print(f"\nGetting not-interacted-with, NEW MATCHES, part {iteration}")
            loadingbar = LoadingBar(len(new_chatids), "new matches")
            for index, chatid in enumerate(new_chatids):
                matches.append(self.get_match(chatid, quickload))
                loadingbar.update_loading(index)
            print("\n")

            # scroll down to get more chatids
            xpath = '//div[@role="tabpanel"]'
            tab = self.browser.find_element(By.XPATH, xpath)
            self.browser.execute_script('arguments[0].scrollTop = arguments[0].scrollHeight;', tab)
            time.sleep(4)

        return matches

    def get_messaged_matches(self, amount, quickload):
        matches = []
        used_chatids = []
        iteration = 0
        while True:
            iteration += 1
            if len(matches) >= amount:
                break

            new_chatids = self.get_chat_ids(new=False, messaged=True)
            copied = new_chatids.copy()
            for index in range(len(copied)):
                if copied[index] in used_chatids:
                    new_chatids.remove(copied[index])
                else:
                    used_chatids.append(new_chatids[index])

            # no new matches are found, MAX LIMIT
            if len(new_chatids) == 0:
                break

            # shorten the list so doesn't fetch ALL matches but just the amount it needs
            diff = len(matches) + len(new_chatids) - amount
            if diff > 0:
                del new_chatids[-diff:]

            print(f"\nGetting interacted-with, MESSAGED MATCHES, part {iteration}")
            loadingbar = LoadingBar(len(new_chatids), "interacted-with-matches")
            for index, chatid in enumerate(new_chatids):
                matches.append(self.get_match(chatid, quickload))
                loadingbar.update_loading(index)
            print("\n")

            # scroll down to get more chatids
            xpath = '//div[@class="messageList"]'
            tab = self.browser.find_element(By.XPATH, xpath)
            self.browser.execute_script('arguments[0].scrollTop = arguments[0].scrollHeight;', tab)
            time.sleep(4)

        return matches

    def send_message(self, chatid, message):
        if not self._is_chat_opened(chatid):
            self._open_chat(chatid)

        # locate the textbox and send message
        try:
            xpath = '//textarea'

            WebDriverWait(self.browser, self.delay).until(
                EC.presence_of_element_located((By.XPATH,xpath)))

            textbox = self.browser.find_element(By.XPATH, xpath)
            textbox.send_keys(message)
            textbox.send_keys(Keys.ENTER)

            print("Message sent succesfully.\nmessage: {}\n".format(message))

            # sleep so message can be sent
            time.sleep(1.5)
        except Exception as e:
            print("SOMETHING WENT WRONG LOCATING TEXTBOX")
            print(e)

    def send_gif(self, chatid, gifname):
        if not self._is_chat_opened(chatid):
            self._open_chat(chatid)

        try:
            xpath = '/html/body/div[1]/div/div[1]/div/main/div[1]/div/div/div/div[1]/div/div/div[3]/div/div[2]/button'

            WebDriverWait(self.browser, self.delay).until(
                EC.presence_of_element_located((By.XPATH, xpath)))
            gif_btn = self.browser.find_element(By.XPATH, xpath)

            gif_btn.click()
            time.sleep(1.5)

            search_box = self.browser.find_element(By.XPATH, '//textarea')
            search_box.send_keys(gifname)
            # give chance to load gif
            time.sleep(1.5)

            gif = self.browser.find_element(By.XPATH, '/html/body/div[1]/div/div[1]/div/main/div[1]/div/div/div/div[1]/div/div/div[3]/div/div/div[1]/div[1]/div/div/div')
            gif.click()
            # sleep so gif can be sent
            time.sleep(1.5)

        except Exception as e:
            print(e)

    def send_song(self, chatid, songname):
        if not self._is_chat_opened(chatid):
            self._open_chat(chatid)

        try:
            xpath = '/html/body/div[1]/div/div[1]/div/main/div[1]/div/div/div/div[1]/div/div/div[4]/div/div[3]/button'

            WebDriverWait(self.browser, self.delay).until(
                EC.presence_of_element_located((By.XPATH, xpath)))
            song_btn = self.browser.find_element(By.XPATH, xpath)

            song_btn.click()
            time.sleep(1.5)

            search_box = self.browser.find_element(By.XPATH, '//textarea')
            search_box.send_keys(songname)
            # give chance to load gif
            time.sleep(1.5)

            song = self.browser.find_element(By.XPATH, 
                '/html/body/div[1]/div/div[1]/div/main/div[1]/div/div/div/div[1]/div/div/div[3]/div/div[2]/div/div[1]/div[1]/div/div[1]/div/button')
            song.click()
            time.sleep(0.5)

            confirm_btn = self.browser.find_element(By.XPATH, '/html/body/div[1]/div/div[1]/div/main/div[1]/div/div/div/div[1]/div/div/div[3]/div/div[2]/div/div[1]/div[2]/div/div[2]/button')
            confirm_btn.click()
            # sleep so song can be sent
            time.sleep(1.5)

        except Exception as e:
            print(e)

    def send_socials(self, chatid, media):
        did_match = False
        for social in (Socials):
            if social == media:
                did_match = True

        if not did_match: print("Media must be of type Socials"); return

        if not self._is_chat_opened(chatid):
            self._open_chat(chatid)

        try:
            xpath = f'{content}/div/div[1]/div/main/div[1]/div/div/div/div[1]/div/div/div[3]/div/div[1]/button'

            WebDriverWait(self.browser, self.delay).until(
                EC.presence_of_element_located((By.XPATH, xpath)))
            socials_btn = self.browser.find_element(By.XPATH, xpath)

            socials_btn.click()
            time.sleep(1)
            
            xpath = '//img[@alt="{}"]'.format(media.value)
            WebDriverWait(self.browser, self.delay).until(
                EC.presence_of_element_located((By.XPATH, xpath)))
            social_btn = self.browser.find_elements(By.XPATH, xpath)[-1]
            social_btn.click()

            # locate the sendbutton and send social
            try:
                self.browser.find_element(By.XPATH, "//button[@type='submit']").click()
                print("Succesfully send social card")
                # sleep so message can be sent
                time.sleep(1.5)
            except Exception as e:
                print("SOMETHING WENT WRONG LOCATING TEXTBOX")
                print(e)

        except Exception as e:
            print(e)
            self.browser.refresh()
            self.send_socials(chatid, media)

    def unmatch(self, chatid):
        if not self._is_chat_opened(chatid):
            self._open_chat(chatid)

        try:
            #'//button[text()="Unmatch"]'
            unmatch_button = self.browser.find_element(By.XPATH, f'{content}/div/div[1]/div/main/div[1]/div/div/div/div[2]/div/div[2]/div/button[1]')
            unmatch_button.click()
            time.sleep(1)


            unmatch_button = self.browser.find_element(By.XPATH, f'{modal_manager}/div/div/div[2]/button[1]')
            unmatch_button.click()
            time.sleep(1)

        except Exception as e:
            print("SOMETHING WENT WRONG FINDING THE UNMATCH BUTTONS")
            print(e)

    def _open_chat(self, chatid):
        if self._is_chat_opened(chatid): return;

        href = "/app/messages/{}".format(chatid)

        # look for the match with that chatid
        # first we're gonna look for the match in the already interacted matches
        try:
            xpath = '//*[@role="tab"]'
            # wait for element to appear
            WebDriverWait(self.browser, self.delay).until(EC.presence_of_element_located((By.XPATH, xpath)))

            tabs = self.browser.find_elements(By.XPATH, xpath)
            for tab in tabs:
                if tab.text == "Messages":
                    tab.click()
            time.sleep(1)
        except Exception as e:
            self.browser.get(self.HOME_URL)
            print(e)
            return self._open_chat(chatid)

        try:
            match_button = self.browser.find_element(By.XPATH, '//a[@href="{}"]'.format(href))
            self.browser.execute_script("arguments[0].click();", match_button)

        except Exception as e:
            # match reference not found, so let's see if match exists in the new not yet interacted matches
            xpath = '//*[@role="tab"]'
            # wait for element to appear
            WebDriverWait(self.browser, self.delay).until(EC.presence_of_element_located((By.XPATH, xpath)))

            tabs = self.browser.find_elements(By.XPATH, xpath)
            for tab in tabs:
                if tab.text == "Matches":
                    tab.click()

            time.sleep(1)

            try:
                matched_button = self.browser.find_element(By.XPATH, '//a[@href="{}"]'.format(href))
                matched_button.click()
            except Exception as e:
                # some kind of error happened, probably cuz chatid/ref/match doesnt exist (anymore)
                # Another error could be that the elements could not be found, cuz we're at a wrong url (potential bug)
                print(e)
        time.sleep(1)

    def get_match(self, chatid, quickload):
        if not self._is_chat_opened(chatid):
            self._open_chat(chatid)

        name = self.get_name(chatid)
        age = self.get_age(chatid)
        bio = self.get_bio(chatid)
        image_urls = self.get_image_urls(chatid, quickload)

        rowdata = self.get_row_data(chatid)
        work = rowdata.get('work')
        study = rowdata.get('study')
        home = rowdata.get('home')
        gender = rowdata.get('gender')
        distance = rowdata.get('distance')

        passions = self.get_passions(chatid)

        return Match(name=name, chatid=chatid, age=age, work=work, study=study, home=home, gender=gender, distance=distance, bio=bio, passions=passions, image_urls=image_urls)

    def get_name(self, chatid):
        if not self._is_chat_opened(chatid):
            self._open_chat(chatid)

        try:
            xpath = f'{content}/div/div[1]/div/main/div[1]/div/div/div/div[2]/div/div[1]/div/div/div[2]/div[1]/div/div[1]/div[1]/h1'
            element = self.browser.find_element(By.XPATH, xpath)
            WebDriverWait(self.browser, self.delay).until(EC.presence_of_element_located((By.XPATH, xpath)))
            return element.text
        except Exception as e:
            print(e)

    def get_age(self, chatid):
        if not self._is_chat_opened(chatid):
            self._open_chat(chatid)

        age = None

        try:
            xpath = f'{content}/div/div[1]/div/main/div[1]/div/div/div/div[2]/div/div[1]/div/div/div[2]/div[1]/div/div[1]/span'
            element = self.browser.find_element(By.XPATH, xpath)
            WebDriverWait(self.browser, self.delay).until(EC.presence_of_element_located(
                (By.XPATH, xpath)))
            try:
               age = int(element.text)
            except ValueError:
                age = None
        except:
            pass

        return age


    _WORK_SVG_PATH = "M7.15 3.434h5.7V1.452a.728.728 0 0 0-.724-.732H7.874a.737.737 0 0 0-.725.732v1.982z"
    _STUDYING_SVG_PATH = "M11.87 5.026L2.186 9.242c-.25.116-.25.589 0 .705l.474.204v2.622a.78.78 0 0 0-.344.657c0 .42.313.767.69.767.378 0 .692-.348.692-.767a.78.78 0 0 0-.345-.657v-2.322l2.097.921a.42.42 0 0 0-.022.144v3.83c0 .45.27.801.626 1.101.358.302.842.572 1.428.804 1.172.46 2.755.776 4.516.776 1.763 0 3.346-.317 4.518-.777.586-.23 1.07-.501 1.428-.803.355-.3.626-.65.626-1.1v-3.83a.456.456 0 0 0-.022-.145l3.264-1.425c.25-.116.25-.59 0-.705L12.13 5.025c-.082-.046-.22-.017-.26 0v.001zm.13.767l8.743 3.804L12 13.392 3.257 9.599l8.742-3.806zm-5.88 5.865l5.75 2.502a.319.319 0 0 0 .26 0l5.75-2.502v3.687c0 .077-.087.262-.358.491-.372.29-.788.52-1.232.68-1.078.426-2.604.743-4.29.743s-3.212-.317-4.29-.742c-.444-.161-.86-.39-1.232-.68-.273-.23-.358-.415-.358-.492v-3.687z"
    _HOME_SVG_PATH = "M19.695 9.518H4.427V21.15h15.268V9.52zM3.109 9.482h17.933L12.06 3.709 3.11 9.482z"
    _LOCATION_SVG_PATH = "M11.436 21.17l-.185-.165a35.36 35.36 0 0 1-3.615-3.801C5.222 14.244 4 11.658 4 9.524 4 5.305 7.267 2 11.436 2c4.168 0 7.437 3.305 7.437 7.524 0 4.903-6.953 11.214-7.237 11.48l-.2.167zm0-18.683c-3.869 0-6.9 3.091-6.9 7.037 0 4.401 5.771 9.927 6.897 10.972 1.12-1.054 6.902-6.694 6.902-10.95.001-3.968-3.03-7.059-6.9-7.059h.001z"

    _WORK_SVG_PATH = "M7.15 3.434h5.7V1.452a.728.728 0 0 0-.724-.732H7.874a.737.737 0 0 0-.725.732v1.982z"
    _STUDYING_SVG_PATH = "M11.87 5.026L2.186 9.242c-.25.116-.25.589 0 .705l.474.204v2.622a.78.78 0 0 0-.344.657c0 .42.313.767.69.767.378 0 .692-.348.692-.767a.78.78 0 0 0-.345-.657v-2.322l2.097.921a.42.42 0 0 0-.022.144v3.83c0 .45.27.801.626 1.101.358.302.842.572 1.428.804 1.172.46 2.755.776 4.516.776 1.763 0 3.346-.317 4.518-.777.586-.23 1.07-.501 1.428-.803.355-.3.626-.65.626-1.1v-3.83a.456.456 0 0 0-.022-.145l3.264-1.425c.25-.116.25-.59 0-.705L12.13 5.025c-.082-.046-.22-.017-.26 0v.001zm.13.767l8.743 3.804L12 13.392 3.257 9.599l8.742-3.806zm-5.88 5.865l5.75 2.502a.319.319 0 0 0 .26 0l5.75-2.502v3.687c0 .077-.087.262-.358.491-.372.29-.788.52-1.232.68-1.078.426-2.604.743-4.29.743s-3.212-.317-4.29-.742c-.444-.161-.86-.39-1.232-.68-.273-.23-.358-.415-.358-.492v-3.687z"
    _HOME_SVG_PATH = "M19.695 9.518H4.427V21.15h15.268V9.52zM3.109 9.482h17.933L12.06 3.709 3.11 9.482z"
    _LOCATION_SVG_PATH = "M11.436 21.17l-.185-.165a35.36 35.36 0 0 1-3.615-3.801C5.222 14.244 4 11.658 4 9.524 4 5.305 7.267 2 11.436 2c4.168 0 7.437 3.305 7.437 7.524 0 4.903-6.953 11.214-7.237 11.48l-.2.167zm0-18.683c-3.869 0-6.9 3.091-6.9 7.037 0 4.401 5.771 9.927 6.897 10.972 1.12-1.054 6.902-6.694 6.902-10.95.001-3.968-3.03-7.059-6.9-7.059h.001z"
    _LOCATION_SVG_PATH_2 = "M11.445 12.5a2.945 2.945 0 0 1-2.721-1.855 3.04 3.04 0 0 1 .641-3.269 2.905 2.905 0 0 1 3.213-.645 3.003 3.003 0 0 1 1.813 2.776c-.006 1.653-1.322 2.991-2.946 2.993zm0-5.544c-1.378 0-2.496 1.139-2.498 2.542 0 1.404 1.115 2.544 2.495 2.546a2.52 2.52 0 0 0 2.502-2.535 2.527 2.527 0 0 0-2.499-2.545v-.008z"
    _GENDER_SVG_PATH = "M15.507 13.032c1.14-.952 1.862-2.656 1.862-5.592C17.37 4.436 14.9 2 11.855 2 8.81 2 6.34 4.436 6.34 7.44c0 3.07.786 4.8 2.02 5.726-2.586 1.768-5.054 4.62-4.18 6.204 1.88 3.406 14.28 3.606 15.726 0 .686-1.71-1.828-4.608-4.4-6.338"

    def get_row_data(self, chatid):
        if not self._is_chat_opened(chatid):
            self._open_chat(chatid)

        rowdata = {}

        xpath = '//div[@class="Row"]'
        rows = self.browser.find_elements(By.XPATH, xpath)

        for row in rows:
            svg = row.find_element(By.XPATH, ".//*[starts-with(@d, 'M')]").get_attribute('d')
            value = row.find_element(By.XPATH, ".//div[2]").text
            if svg == self._WORK_SVG_PATH:
                rowdata['work'] = value
            if svg == self._STUDYING_SVG_PATH:
                rowdata['study'] = value
            if svg == self._HOME_SVG_PATH:
                rowdata['home'] = value.split(' ')[-1]
            if svg == self._GENDER_SVG_PATH:
                rowdata['gender'] = value
            if svg == self._LOCATION_SVG_PATH or svg == self._LOCATION_SVG_PATH_2:
                distance = value.split(' ')[0]
                try:
                    distance = int(distance)
                except TypeError:
                    # Means the text has a value of 'Less than 1 km away'
                    distance = 1
                except ValueError:
                    distance = None

                rowdata['distance'] = distance

        return rowdata

    def get_passions(self, chatid):
        if not self._is_chat_opened(chatid):
            self._open_chat(chatid)

        passions = []
        xpath = f'{content}/div/div[1]/div/main/div[1]/div/div/div/div[2]/div/div[1]/div/div/div[2]/div/div/div[2]/div[2]/div'
        elements = self.browser.find_elements(By.XPATH, xpath)
        for el in elements:
            passions.append(el.text)

        return passions

    def get_bio(self, chatid):
        if not self._is_chat_opened(chatid):
            self._open_chat(chatid)

        try:
            xpath = f'{content}/div/div[1]/div/main/div[1]/div/div/div/div[2]/div/div[1]/div/div/div[2]/div[2]/div'
            return self.browser.find_element(By.XPATH, xpath).text
        except:
            # no bio included?
            return None

    def get_image_urls(self, chatid, quickload):
        try:
            if not self._is_chat_opened(chatid):
                self._open_chat(chatid)

            image_urls = []

            # only get url of first few images, and not click all bullets to get all image
            elements = self.browser.find_elements(By.XPATH, "//div[@aria-label='Profile slider']")
            for element in elements:
                image_url = element.value_of_css_property('background-image').split('\"')[1]
                if image_url not in image_urls:
                    image_urls.append(image_url)


            # return image urls without opening all images
            if quickload:
                return image_urls

            classname = 'bullet'
            # wait for element to appear
            WebDriverWait(self.browser, self.delay).until(EC.presence_of_element_located(
                (By.CLASS_NAME, classname)))

            image_btns = self.browser.find_elements_by_class_name(classname)

            for btn in image_btns:
                btn.click()
                time.sleep(1)

                elements = self.browser.find_elements(By.XPATH, "//div[@aria-label='Profile slider']")
                for element in elements:
                    image_url = element.value_of_css_property('background-image').split('\"')[1]
                    if image_url not in image_urls:
                        image_urls.append(image_url)

        except StaleElementReferenceException:
            pass

        except TimeoutException:
            pass

        except Exception as e:
            print("unhandled exception getImageUrls in match_helper")
            print(e)

        return image_urls

    def _is_chat_opened(self, chatid):
        # open the correct user if not happened yet
        if chatid in self.browser.current_url:
            return True
        else:
            return False

```

tinderbotz/helpers/preferences_helper.py:
```
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.common.exceptions import TimeoutException, NoSuchElementException
from selenium.webdriver.common.action_chains import ActionChains

from tinderbotz.helpers.constants_helper import Sexuality
import time

class PreferencesHelper:

    delay = 5

    HOME_URL = "https://www.tinder.com/app/profile"

    def __init__(self, browser):
        self.browser = browser

        # open profile
        try:
            xpath = '//*[@href="/app/profile"]'
            WebDriverWait(self.browser, self.delay).until(
                EC.presence_of_element_located((By.XPATH, xpath)))
            browser.find_element(By.XPATH, xpath).click()
        except:
            pass

    def set_distance_range(self, km):
        # correct out of bounds values
        if km > 160:
            final_percentage = 100
        elif km < 2:
            final_percentage = 0
        else:
            final_percentage = (km / 160) * 100

        possible_xpaths = ['//*[@aria-label="Maximum distance in kilometres"]',
                           '//*[@aria-label="Maximum distance in kilometers"]',
                           '//*[@aria-label="Maximum distance in miles"]']

        for xpath in possible_xpaths:
            try:
                WebDriverWait(self.browser, self.delay).until(
                    EC.presence_of_element_located((By.XPATH, xpath)))
                link = self.browser.find_element(By.XPATH, xpath)
                break
            except TimeoutException:
                continue

        print("\nSlider of distance will be adjusted...")
        current_percentage = float(link.get_attribute('style').split(' ')[1].split('%')[0])
        print("from {}% = {}km".format(current_percentage, current_percentage*1.6))
        print("to {}% = {}km".format(final_percentage, final_percentage*1.6))
        print("with a fault margin of 1%\n")

        # start adjusting the distance slider
        while abs(final_percentage - current_percentage) > 1:
            ac = ActionChains(self.browser)
            if current_percentage < final_percentage:
                ac.click_and_hold(link).move_by_offset(3, 0).release(link).perform()
            elif current_percentage > final_percentage:
                ac.click_and_hold(link).move_by_offset(-3, 0).release(link).perform()
            # update current percentage
            current_percentage = float(link.get_attribute('style').split(' ')[1].split('%')[0])

        print("Ended slider with {}% = {}km\n\n".format(current_percentage, current_percentage*1.6))
        time.sleep(5)

    def set_age_range(self, min, max):
        # locate elements
        xpath = '//*[@aria-label="Minimum age"]'
        WebDriverWait(self.browser, self.delay).until(
            EC.presence_of_element_located((By.XPATH, xpath)))
        btn_minage = self.browser.find_element(By.XPATH, xpath)

        xpath = '//*[@aria-label="Maximum age"]'
        WebDriverWait(self.browser, self.delay).until(
            EC.presence_of_element_located((By.XPATH, xpath)))
        btn_maxage = self.browser.find_element(By.XPATH, xpath)

        min_age_tinder = int(btn_maxage.get_attribute('aria-valuemin'))
        max_age_tinder = int(btn_maxage.get_attribute('aria-valuemax'))

        # correct out of bounds values
        if min < min_age_tinder:
            min = min_age_tinder

        if max > max_age_tinder:
            max = max_age_tinder

        while max-min < 5:
            max += 1
            min -= 1

            if min < min_age_tinder:
                min = min_age_tinder
            if max > max_age_tinder:
                max = max_age_tinder

        range_ages_tinder = max_age_tinder - min_age_tinder
        percentage_per_year = 100 / range_ages_tinder

        to_percentage_min = (min - min_age_tinder) * percentage_per_year
        to_percentage_max = (max - min_age_tinder) * percentage_per_year

        current_percentage_min = float(btn_minage.get_attribute('style').split(' ')[1].split('%')[0])
        current_percentage_max = float(btn_maxage.get_attribute('style').split(' ')[1].split('%')[0])

        print("\nSlider of ages will be adjusted...")
        print("Minimum age will go ...")
        print("from {}% = {} years old".format(current_percentage_min,
                                               (current_percentage_min/percentage_per_year)+min_age_tinder))
        print("to {}% = {} years old".format(to_percentage_min, min))
        print("Maximum age will go ...")
        print("from {}% = {} years old".format(current_percentage_max,
                                               (current_percentage_max / percentage_per_year) + min_age_tinder))
        print("to {}% = {} years old".format(to_percentage_max, max))
        print("with a fault margin of 1%\n")

        # start adjusting the distance slider
        while abs(to_percentage_min - current_percentage_min) > 1 or abs(to_percentage_max - current_percentage_max) > 1:
            ac = ActionChains(self.browser)

            if current_percentage_min < to_percentage_min:
                ac.click_and_hold(btn_minage).move_by_offset(5, 0).release(btn_minage).perform()
            elif current_percentage_min > to_percentage_min:
                ac.click_and_hold(btn_minage).move_by_offset(-5, 0).release(btn_minage).perform()

            ac = ActionChains(self.browser)
            if current_percentage_max < to_percentage_max:
                ac.click_and_hold(btn_maxage).move_by_offset(5, 0).release(btn_maxage).perform()
            elif current_percentage_max > to_percentage_max:
                ac.click_and_hold(btn_maxage).move_by_offset(-5, 0).release(btn_maxage).perform()

            # update current percentage
            current_percentage_min = float(btn_minage.get_attribute('style').split(' ')[1].split('%')[0])
            current_percentage_max = float(btn_maxage.get_attribute('style').split(' ')[1].split('%')[0])

        print("Ended slider with ages from {} years old  to {} years old\n\n".format((current_percentage_min/percentage_per_year)+min_age_tinder,
              (current_percentage_max / percentage_per_year) + min_age_tinder))
        time.sleep(5)

    def set_sexualitiy(self, type):
        if not isinstance(type, Sexuality):
            assert False

        xpath = '//*[@href="/app/settings/gender"]/div/div/div/div'
        WebDriverWait(self.browser, self.delay).until(
            EC.presence_of_element_located((By.XPATH, xpath)))
        element = self.browser.find_element(By.XPATH, xpath)
        element.click()

        xpath = '//*[@aria-pressed="false"]'.format(type.value)
        WebDriverWait(self.browser, self.delay).until(
            EC.presence_of_element_located((By.XPATH, xpath)))
        elements = self.browser.find_elements(By.XPATH, xpath)

        for element in elements:
            if element.find_element(By.XPATH, './/div/label').text == type.value:
                element.click()
                break

        print("clicked on " + type.value)
        time.sleep(5)

    def set_global(self, boolean, language=None):
        # check if global is already activated
        # Global is activated when the href to preferred languages is visible
        is_activated = False
        try:
            xpath = '//*[@href="/app/settings/global/languages"]/div'
            WebDriverWait(self.browser, self.delay).until(
                EC.presence_of_element_located((By.XPATH, xpath)))
            self.browser.find_element(By.XPATH, xpath)
            is_activated = True

        except:
            pass

        if boolean != is_activated:
            xpath = '//*[@name="global"]'
            element = self.browser.find_element(By.XPATH, xpath)
            element.click()

        if is_activated and language:
            print("\nUnfortunately, Languages setting feature does not yet exist")
            print("If needed anyways:\nfeel free to open an issue and ask for the feature")
            print("or contribute by making a pull request.\n")

            '''
            languages_element.click()
            xpath = "//*[contains(text(), {})]".format(language)
            WebDriverWait(self.browser, self.delay).until(
                    EC.presence_of_element_located((By.XPATH, xpath)))
            self.browser.find_elements(By.XPATH, xpath).click()
            '''
            time.sleep(5)

```

tinderbotz/helpers/profile_helper.py:
```
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.common.exceptions import TimeoutException, NoSuchElementException
from selenium.webdriver.common.action_chains import ActionChains
from tinderbotz.helpers.xpaths import content, modal_manager
from selenium.webdriver.common.keys import Keys

import time, os

class ProfileHelper:

    delay = 5

    HOME_URL = "https://www.tinder.com/app/profile"

    def __init__(self, browser):
        self.browser = browser

        # open profile
        try:
            xpath = '//*[@href="/app/profile"]'
            WebDriverWait(self.browser, self.delay).until(
                EC.presence_of_element_located((By.XPATH, xpath)))
            browser.find_element(By.XPATH, xpath).click()
        except:
            pass

        self._edit_info()

    def _edit_info(self):
        xpath = '//a[@href="/app/profile/edit"]'

        try:
            WebDriverWait(self.browser, self.delay).until(
                    EC.presence_of_element_located((By.XPATH, xpath)))
            self.browser.find_element(By.XPATH, xpath).click()
            time.sleep(1)
        except Exception as e:
            print(e)

    def _save(self):
        xpath = f"{content}/div/div[1]/div/main/div[1]/div/div/div/div/div[1]/a"
        try:
            WebDriverWait(self.browser, self.delay).until(
                    EC.presence_of_element_located((By.XPATH, xpath)))
            self.browser.find_element(By.XPATH, xpath).click()
            time.sleep(1)
        except Exception as e:
            print(e)

    def add_photo(self, filepath):
        # get the absolute filepath instead of the relative one
        filepath = os.path.abspath(filepath)

        # "add media" button
        xpath = f'{content}/div/div[1]/div/main/div[1]/div/div/div/div/div[2]/span/button'
        try:
            WebDriverWait(self.browser, self.delay).until(
                    EC.presence_of_element_located((By.XPATH, xpath)))
            btn = self.browser.find_element(By.XPATH, xpath)
            self.browser.execute_script("arguments[0].scrollIntoView();", btn)
            btn.click()
        except Exception as e:
            print(e)

        xpath_input = f"{modal_manager}/div/div/div[1]/div[2]/div[2]/div/div/input"
        try:
            WebDriverWait(self.browser, self.delay).until(
                    EC.presence_of_element_located((By.XPATH, xpath_input)))
            self.browser.find_element(By.XPATH, xpath_input).send_keys(filepath)
        except Exception as e:
            print(e)

        xpath_choose = f"{modal_manager}/div/div/div[1]/div[1]/button[2]"
        try:
            WebDriverWait(self.browser, self.delay).until(
                    EC.presence_of_element_located((By.XPATH, xpath_choose)))
            self.browser.find_element(By.XPATH, xpath_choose).click()
        except Exception as e:
            print(e)

        self._save()

    def set_bio(self, bio):
        xpath = f"{content}/div/div[1]/div/main/div[1]/div/div/div/div/div[2]/div[2]/div/textarea"

        try:
            WebDriverWait(self.browser, self.delay).until(
                    EC.presence_of_element_located((By.XPATH, xpath)))
            text_area = self.browser.find_element(By.XPATH, xpath)

            for _ in range(500):
                text_area.send_keys(Keys.BACKSPACE)

            time.sleep(1)
            text_area.send_keys(bio)
            time.sleep(1)
        except Exception as e:
            print(e)

        self._save()

```

tinderbotz/helpers/storage_helper.py:
```
import string
import random
import os
import json
import time

import urllib.request
from PIL import Image
import hashlib


class StorageHelper:

    @staticmethod
    def id_generator(size=6, chars=string.ascii_uppercase + string.digits):
        return ''.join(random.choice(chars) for _ in range(size))

    # Returns hash value of the image saved by the url given
    @staticmethod
    def store_image_as(url, directory, amount_of_attempts=1):
        if not os.path.exists(directory):
            os.makedirs(directory)

        # make 'undetectable' header to avoid being seen as scraper
        headers = {
            'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.11 (KHTML, like Gecko) Chrome/23.0.1271.64 Safari/537.11',
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
            'Accept-Charset': 'ISO-8859-1,utf-8;q=0.7,*;q=0.3',
            'Accept-Encoding': 'none',
            'Accept-Language': 'en-US,en;q=0.8',
            'Connection': 'keep-alive'}

        try:
            request_ = urllib.request.Request(url, None, headers)  # The assembled request
            response = urllib.request.urlopen(request_)  # store the response

        except Exception as e:
            if amount_of_attempts < 20:
                sleepy_time = amount_of_attempts * 30
                print("Attempt number {}: sleeping for {} seconds ...".format(amount_of_attempts, sleepy_time))
                time.sleep(sleepy_time)
                return StorageHelper.store_image_as(url, directory, amount_of_attempts + 1)
            else:
                # Settle with the fact this one won't be stored
                error = "Amount of attempts exceeded in storage_helper\n" \
                        "attempting to get url: {}\n" \
                        "resulted in error: {}".format(url, e)
                print(error)
                return None

        temp_name = "temporary"

        if ".jpg" in url:
            f = open("{}/{}/{}.jpg".format(os.getcwd(), directory, temp_name), 'wb')
            f.write(response.read())
            f.close()

        elif '.webp' in url:
            # save as a temporary file
            f = open("{}.webp".format(temp_name), 'wb')
            f.write(response.read())
            f.close()

            # open the file and convert the file to jpeg
            im = Image.open("{}.webp".format(temp_name)).convert("RGB")
            # save the jpeg file in the directory it belongs
            im.save("{}/{}/{}.jpg".format(os.getcwd(), directory, temp_name), "jpeg")

            # remove the temporary file
            os.remove("{}.webp".format(temp_name))

        else:
            print("URL of image cannot be saved!")
            print("URL DOES NOT CONTAIN .JPG OR .WEBP EXTENSION")
            print(url)

            error = "URL DOES NOT CONTAIN .JPG OR .WEBP EXTENSION: {}\n" \
                    "Please add extension needed in storage_helper".format(url)
            print(error)

        # rename saved image to their hashvalue, so it's easy to compare (hashes of) images later on
        im = Image.open('{}/{}/{}.jpg'.format(os.getcwd(), directory, temp_name))
        hashvalue = hashlib.md5(im.tobytes()).hexdigest()

        # check if image already exists
        if not os.path.isfile('{}/{}/{}.jpg'.format(os.getcwd(), directory, hashvalue)):
            os.rename('{}/{}/{}.jpg'.format(os.getcwd(), directory, temp_name),
                      '{}/{}/{}.jpg'.format(os.getcwd(), directory, hashvalue))

        print("Image saved as {}/{}/{}.jpg".format(os.getcwd(), directory, hashvalue))

        return hashvalue

    @staticmethod
    def store_match(match, directory, filename):

        if not os.path.exists(directory):
            os.makedirs(directory)

        filepath = directory + "/{}.json".format(filename)

        try:
            with open(filepath, "r", encoding='utf-8') as fp:
                data = json.load(fp)
        except IOError:
            print("Could not read file, starting from scratch")
            data = {}

        data[match.get_id()] = match.get_dictionary()

        with open(filepath, 'w+', encoding="utf-8") as file:
            json.dump(data, file)

```

tinderbotz/helpers/xpaths.py:
```
content = '/html/body/div[1]' #'//div[starts-with(@id, "q-")]'

modal_manager = '/html/body/div[2]' #'//div[starts-with(@id, "q")]'
```

tinderbotz/session.py:
```
# Selenium: automation of browser
from selenium import webdriver
# from webdriver_manager.chrome import ChromeDriverManager
import undetected_chromedriver.v2 as uc
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
from selenium.common.exceptions import NoSuchElementException, TimeoutException, ElementNotVisibleException
from selenium.webdriver.common.by import By


# some other imports :-)
import os
import platform
import time
import random
import requests
import atexit
from pathlib import Path

# Tinderbotz: helper classes
from tinderbotz.helpers.geomatch import Geomatch
from tinderbotz.helpers.match import Match
from tinderbotz.helpers.profile_helper import ProfileHelper
from tinderbotz.helpers.preferences_helper import PreferencesHelper
from tinderbotz.helpers.geomatch_helper import GeomatchHelper
from tinderbotz.helpers.match_helper import MatchHelper
from tinderbotz.helpers.login_helper import LoginHelper
from tinderbotz.helpers.storage_helper import StorageHelper
from tinderbotz.helpers.email_helper import EmailHelper
from tinderbotz.helpers.constants_helper import Printouts
from tinderbotz.helpers.xpaths import *
from tinderbotz.addproxy import get_proxy_extension


class Session:
    HOME_URL = "https://www.tinder.com/app/recs"

    def __init__(self, headless=False, store_session=True, proxy=None, user_data=False):
        self.email = None
        self.may_send_email = False
        self.session_data = {
            "duration": 0,
            "like": 0,
            "dislike": 0,
            "superlike": 0
        }

        start_session = time.time()

        # this function will run when the session ends
        @atexit.register
        def cleanup():
            # End session duration
            seconds = int(time.time() - start_session)
            self.session_data["duration"] = seconds

            # add session data into a list of messages
            lines = []
            for key in self.session_data:
                message = "{}: {}".format(key, self.session_data[key])
                lines.append(message)

            # print out the statistics of the session
            try:
                box = self._get_msg_box(lines=lines, title="Tinderbotz")
                print(box)
            finally:
                print("Started session: {}".format(self.started))
                y = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime())
                print("Ended session: {}".format(y))
            
            # Close browser properly
            self.browser.quit()

        # Go further with the initialisation
        # Setting some options of the browser here below

        options = uc.ChromeOptions()

        # Create empty profile to avoid annoying Mac Popup
        if store_session:
            if not user_data:
                user_data = f"{Path().absolute()}/chrome_profile/"
            if not os.path.isdir(user_data):
                os.mkdir(user_data)

            Path(f'{user_data}First Run').touch()
            options.add_argument(f"--user-data-dir={user_data}")

        #options.add_argument("--start-maximized")
        options.add_argument('--no-first-run --no-service-autorun --password-store=basic')
        options.add_argument("--lang=en-GB")

        if headless:
            options.headless = True

        if proxy:
            if '@' in proxy:
                parts = proxy.split('@')

                user = parts[0].split(':')[0]
                pwd = parts[0].split(':')[1]

                host = parts[1].split(':')[0]
                port = parts[1].split(':')[1]

                extension = get_proxy_extension(PROXY_HOST=host, PROXY_PORT=port, PROXY_USER=user, PROXY_PASS=pwd)
                options.add_extension(extension)
            else:
                options.add_argument(f'--proxy-server=http://{proxy}')

        # Getting the chromedriver from cache or download it from internet
        print("Getting ChromeDriver ...")
        self.browser = uc.Chrome(options=options)  # ChromeDriverManager().install(),
        # self.browser = webdriver.Chrome(options=options)
        # self.browser.set_window_size(1250, 750)

        # clear the console based on the operating system you're using
        #os.system('cls' if os.name == 'nt' else 'clear')

        # Cool banner
        print(Printouts.BANNER.value)
        time.sleep(1)

        self.started = time.strftime("%Y-%m-%d %H:%M:%S", time.localtime())
        print("Started session: {}\n\n".format(self.started))

    # Setting a custom location
    def set_custom_location(self, latitude, longitude, accuracy="100%"):

        params = {
            "latitude": latitude,
            "longitude": longitude,
            "accuracy": int(accuracy.split('%')[0])
        }

        self.browser.execute_cdp_cmd("Page.setGeolocationOverride", params)

    # This will send notification when you get a match to your email used to logged in.
    def set_email_notifications(self, boolean):
        self.may_send_email = boolean

    # NOTE: Need to be logged in for this
    def set_distance_range(self, km):
        helper = PreferencesHelper(browser=self.browser)
        helper.set_distance_range(km)

    def set_age_range(self, min, max):
        helper = PreferencesHelper(browser=self.browser)
        helper.set_age_range(min, max)

    def set_sexuality(self, type):
        helper = PreferencesHelper(browser=self.browser)
        helper.set_sexualitiy(type)

    def set_global(self, boolean):
        helper = PreferencesHelper(browser=self.browser)
        helper.set_global(boolean)

    def set_bio(self, bio):
        helper = ProfileHelper(browser=self.browser)
        helper.set_bio(bio)

    def add_photo(self, filepath):
        helper = ProfileHelper(browser=self.browser)
        helper.add_photo(filepath)

    # Actions of the session
    def login_using_google(self, email, password):
        self.email = email
        if not self._is_logged_in():
            helper = LoginHelper(browser=self.browser)
            helper.login_by_google(email, password)
            time.sleep(5)
        if not self._is_logged_in():
            print('Manual interference is required.')
            input('press ENTER to continue')

    def login_using_facebook(self, email, password):
        self.email = email
        if not self._is_logged_in():
            helper = LoginHelper(browser=self.browser)
            helper.login_by_facebook(email, password)
            time.sleep(5)
        if not self._is_logged_in():
            print('Manual interference is required.')
            input('press ENTER to continue')

    def login_using_sms(self, country, phone_number):
        if not self._is_logged_in():
            helper = LoginHelper(browser=self.browser)
            helper.login_by_sms(country, phone_number)
            time.sleep(5)
        if not self._is_logged_in():
            print('Manual interference is required.')
            input('press ENTER to continue')

    def store_local(self, match):
        if isinstance(match, Match):
            filename = 'matches'
        elif isinstance(match, Geomatch):
            filename = 'geomatches'
        else:
            print("type of match is unknown, storing local impossible")
            print("Crashing in 3.2.1... :)")
            assert False

        # store its images
        for url in match.image_urls:
            hashed_image = StorageHelper.store_image_as(url=url, directory='data/{}/images'.format(filename))
            match.images_by_hashes.append(hashed_image)

        # store its userdata
        StorageHelper.store_match(match=match, directory='data/{}'.format(filename), filename=filename)

    def like(self, amount=1, ratio='100%', sleep=1, randomize_sleep = True):
        
        initial_sleep = sleep
        ratio = float(ratio.split('%')[0]) / 100

        if self._is_logged_in():
            helper = GeomatchHelper(browser=self.browser)
            amount_liked = 0
            # handle one time up front, from then on check after every action instead of before
            self._handle_potential_popups()
            print("\nLiking profiles started.")
            while amount_liked < amount:
                # randomize sleep
                if randomize_sleep:
                    sleep = random.uniform(0.5, 2.3) * initial_sleep
                if random.random() <= ratio:
                    if helper.like():
                        amount_liked += 1
                        # update for stats after session ended
                        self.session_data['like'] += 1
                        print(f"{amount_liked}/{amount} liked, sleep: {sleep}")
                else:
                    helper.dislike()
                    # update for stats after session ended
                    self.session_data['dislike'] += 1

                #self._handle_potential_popups()
                time.sleep(sleep)

            self._print_liked_stats()

    def dislike(self, amount=1):
        if self._is_logged_in():
            helper = GeomatchHelper(browser=self.browser)
            for _ in range(amount):
                self._handle_potential_popups()
                helper.dislike()

                # update for stats after session ended
                self.session_data['dislike'] += 1
                #time.sleep(1)
            self._print_liked_stats()

    def superlike(self, amount=1):
        if self._is_logged_in():
            helper = GeomatchHelper(browser=self.browser)
            for _ in range(amount):
                self._handle_potential_popups()
                helper.superlike()
                # update for stats after session ended
                self.session_data['superlike'] += 1
                time.sleep(1)
            self._print_liked_stats()

    def get_geomatch(self, quickload=True):
        if self._is_logged_in():
            helper = GeomatchHelper(browser=self.browser)
            self._handle_potential_popups()

            name = None
            attempts = 0
            max_attempts = 3
            while not name and attempts < max_attempts:
                attempts += 1
                name = helper.get_name()
                self._handle_potential_popups() # Popup handling on first geomatch
                time.sleep(1)

            age = helper.get_age()

            bio, passions, lifestyle, basics, anthem, looking_for = helper.get_bio_and_passions()
            image_urls = helper.get_image_urls(quickload)
            instagram = helper.get_insta(bio)
            rowdata = helper.get_row_data()
            work = rowdata.get('work')
            study = rowdata.get('study')
            home = rowdata.get('home')
            distance = rowdata.get('distance')
            gender = rowdata.get('gender')

            return Geomatch(name=name, age=age, work=work, gender=gender, study=study, home=home, distance=distance,
                            bio=bio, passions=passions, lifestyle=lifestyle, basics=basics, anthem=anthem, looking_for=looking_for, image_urls=image_urls, instagram=instagram)

    def get_chat_ids(self, new=True, messaged=True):
        if self._is_logged_in():
            helper = MatchHelper(browser=self.browser)
            self._handle_potential_popups()
            return helper.get_chat_ids(new, messaged)

    def get_new_matches(self, amount=100000, quickload=True):
        if self._is_logged_in():
            helper = MatchHelper(browser=self.browser)
            self._handle_potential_popups()
            return helper.get_new_matches(amount, quickload)

    def get_messaged_matches(self, amount=100000, quickload=True):
        if self._is_logged_in():
            helper = MatchHelper(browser=self.browser)
            self._handle_potential_popups()
            return helper.get_messaged_matches(amount, quickload)

    def send_message(self, chatid, message):
        if self._is_logged_in():
            helper = MatchHelper(browser=self.browser)
            self._handle_potential_popups()
            helper.send_message(chatid, message)

    def send_gif(self, chatid, gifname):
        if self._is_logged_in():
            helper = MatchHelper(browser=self.browser)
            self._handle_potential_popups()
            helper.send_gif(chatid, gifname)

    def send_song(self, chatid, songname):
        if self._is_logged_in():
            helper = MatchHelper(browser=self.browser)
            self._handle_potential_popups()
            helper.send_song(chatid, songname)

    def send_socials(self, chatid, media):
        if self._is_logged_in():
            helper = MatchHelper(browser=self.browser)
            self._handle_potential_popups()
            helper.send_socials(chatid, media)

    def unmatch(self, chatid):
        if self._is_logged_in():
            helper = MatchHelper(browser=self.browser)
            self._handle_potential_popups()
            helper.unmatch(chatid)

    # Utilities
    def _handle_potential_popups(self):
        delay = 0.25

        # last possible id based div
        base_element = self.browser.find_element(By.XPATH, modal_manager)

        # try to deny see who liked you
        try:
            xpath = './/main/div/div/div[3]/button[2]'
            WebDriverWait(base_element, delay).until(
                EC.presence_of_element_located((By.XPATH, xpath)))

            deny_btn = base_element.find_element(By.XPATH, xpath)
            deny_btn.click()
            return "POPUP: Denied see who liked you"

        except NoSuchElementException:
            pass
        except TimeoutException:
            pass

        # Try to dismiss a potential 'upgrade like' popup
        try:
            # locate "no thanks"-button
            xpath = './/main/div/button[2]'
            base_element.find_element(By.XPATH, xpath).click()
            return "POPUP: Denied upgrade to superlike"
        except NoSuchElementException:
            pass

        # try to deny 'add tinder to homescreen'
        try:
            xpath = './/main/div/div[2]/button[2]'

            add_to_home_popup = base_element.find_element(By.XPATH, xpath)
            add_to_home_popup.click()
            return "POPUP: Denied Tinder to homescreen"

        except NoSuchElementException:
            pass

        # deny buying more superlikes
        try:
            xpath = './/main/div/div[3]/button[2]'
            deny = base_element.find_element(By.XPATH, xpath)
            deny.click()
            return "POPUP: Denied buying more superlikes"
        except NoSuchElementException:
            pass

        # try to dismiss match
        matched = False
        try:
            xpath = '//button[@title="Back to Tinder"]'

            match_popup = base_element.find_element(By.XPATH, xpath)
            match_popup.click()
            matched = True

        except NoSuchElementException:
            pass
        except:
            matched = True
            self.browser.refresh()

        if matched and self.may_send_email:
            try:
                EmailHelper.send_mail_match_found(self.email)
            except:
                print("Some error occurred when trying to send mail.")
                print("Consider opening an Issue on Github.")
                pass
            return "POPUP: Dismissed NEW MATCH"

        # try to say 'no thanks' to buy more (super)likes
        try:
            xpath = './/main/div/div[3]/button[2]'
            deny_btn = base_element.find_element(By.XPATH, xpath)
            deny_btn.click()
            return "POPUP: Denied buying more superlikes"

        except ElementNotVisibleException:
            # element is not clickable, probably cuz it's out of view but still there
            self.browser.refresh()
        except NoSuchElementException:
            pass
        except:
            # TBD add stale element exception for now just refresh page
            self.browser.refresh()
            pass

        # Deny confirmation of email
        try:
            xpath = './/main/div/div[1]/div[2]/button[2]'
            remindmelater = base_element.find_element(By.XPATH, xpath)
            remindmelater.click()

            time.sleep(3)
            # handle other potential popups
            self._handle_potential_popups()
            return "POPUP: Deny confirmation of email"
        except:
            pass

        # Deny add location popup
        try:
            xpath = ".//*[contains(text(), 'No Thanks')]"
            nothanks = base_element.find_element(By.XPATH, xpath)
            nothanks.click()
            time.sleep(3)
            # handle other potential popups
            self._handle_potential_popups()
            return "POPUP: Deny confirmation of email"
        except:
            pass

        return None

    def _is_logged_in(self):
        # make sure tinder website is loaded for the first time
        if not "tinder" in self.browser.current_url:
            # enforce english language
            self.browser.get("https://tinder.com/?lang=en")
            time.sleep(1.5)

        if "tinder.com/app/" in self.browser.current_url:
            return True
        else:
            print("User is not logged in yet.\n")
            return False

    def _get_msg_box(self, lines, indent=1, width=None, title=None):
        """Print message-box with optional title."""
        space = " " * indent
        if not width:
            width = max(map(len, lines))
        box = f'/{"=" * (width + indent * 2)}\\\n'  # upper_border
        if title:
            box += f'|{space}{title:<{width}}{space}|\n'  # title
            box += f'|{space}{"-" * len(title):<{width}}{space}|\n'  # underscore
        box += ''.join([f'|{space}{line:<{width}}{space}|\n' for line in lines])
        box += f'\\{"=" * (width + indent * 2)}/'  # lower_border
        return box

    def _print_liked_stats(self):
        likes = self.session_data['like']
        dislikes = self.session_data['dislike']
        superlikes = self.session_data['superlike']

        if superlikes > 0:
            print(f"You've superliked {self.session_data['superlike']} profiles during this session.")
        if likes > 0:
            print(f"You've liked {self.session_data['like']} profiles during this session.")
        if dislikes > 0:
            print(f"You've disliked {self.session_data['dislike']} profiles during this session.")


```
